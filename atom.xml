<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>javadaydayup&#39;s blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-12-27T01:23:09.370Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>javadaydayup</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java 中的这个绝对值有点不绝对啊！</title>
    <link href="http://example.com/2024/12/24/java-zhong-de-zhe-ge-jue-dui-zhi-you-dian-bu-jue-dui-a/"/>
    <id>http://example.com/2024/12/24/java-zhong-de-zhe-ge-jue-dui-zhi-you-dian-bu-jue-dui-a/</id>
    <published>2024-12-24T13:15:04.000Z</published>
    <updated>2024-12-27T01:23:09.370Z</updated>
    
    <content type="html"><![CDATA[<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>假如有如下代码定义了一个方法 <code>test()</code>，它入参可以任何一个 int 类型的整数，那么它输出结果可能是什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a)</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;The result of absolute value compare to zero is:&quot;</span> + (Math.abs(a) &gt;= <span class="number">0</span>));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你的结论是 true，那么恭喜你，你掉入到<strong>绝对值不绝对</strong>的坑里面了。这个方法输出的结果<strong>有可能是 true，但是也有可能是 false</strong>。比如下面的调用代码将分别输出 true，true，true , false，如下图所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">test(<span class="number">1</span>);</span><br><span class="line">test(-<span class="number">1</span>);</span><br><span class="line">test(Integer.MAX_VALUE);</span><br><span class="line">test(Integer.MIN_VALUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241222155212.png"></p><p>在 Java 中，通过 <code>Math.abs()</code> 函数返回的值有的时候并不是这个数的绝对值。如下面的代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">System.out.println(Math.abs(Integer.MIN_VALUE));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码输出的结果并不是 <code>Integer.MIN_VALUE</code> 的绝对值，输出的结果是它自己，如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241222162701.png"></p><p>从输出可以看到因为 <code>Math.abs(Integer.MIN_VALUE)</code> 的结果还是 <code>Integer.MIN_VALUE</code>，因此它是小于 0 的，这个也解释了上面判断大于等于 0 结果有可能输出的是 false。</p><p>为什么  <code>Math.abs(Integer.MIN_VALUE)</code> 的结果还是 <code>Integer.MIN_VALUE</code> 而不是它的绝对值呢？</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>从 <code>int</code> 类型可以表示的数的范围解释是比较好理解的。以 <code>int</code> 类型为例，它能够表示的范围是 2^31 到 2^31 - 1。即 -2147483648 到 2147483647，可以看到最小的负数是 -2147483648 。它的绝对值实际上应该是 2147483648，但是这个值已经超过了 <code>int</code> 类型能够表示的最大的数 2147483647 了。如果返回 2147483648，它是不能在一个 <code>int</code> 类型的数中表示的。如果我们直接把 2147483648 这个数赋值给一个 <code>int</code> 类型的变量，编译器也会提示 <code>Integer number too large</code>，如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241222163625.png"></p><p>因此这里 <code>Math.abs()</code> 函数返回的结果并不能是 214748364，因为 <code>int</code> 类型根本表示不了这个数。</p><p>那 <code>Math.abs()</code> 方法做了什么操作呢？查看 <code>Math.abs()</code> 方法的源码，实现逻辑如下：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241222101508.png"></p><p>在方法中就是判断了一下这个数是否小于 0，如果小于 0 的话，就返回对这个数取反后的值。那这个取反操作具体做了什么事情呢？为什么对 <code>Integer.MIN_VALUE</code> 进行了求反操作返回的还是它自己？</p><p>要回答这些问题，那就得知道计算机底层是表示一个整数的方式以及 <code>int</code> 类型表示的数的范围是 2^31 到 2^31 - 1 的原因。</p><p><a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.15.4">Java语言规范</a>中对此做了描述，规范中说到 Java 语言中使用 「<strong>two’s-complement representation</strong>」 来表示整数，因为 「<strong>two’s-complement representation</strong>」 的值不是对称的，所以对 <code>int</code> 或者 <code>long</code> 类型的最小值的取反的结果还是它们自身，在这个场景是有「<strong>溢出</strong>」发生的。而对一个整数的取反操作相当于把它的所有比特位取反，然后再加上 1。如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241222164935.png"></p><p>规范这里的提到的 「<strong>two’s-complement</strong>」 就是我们常常说的「<strong>补码</strong>」，学过计算机组成原理相关课程的应该对这个词语比较耳熟。</p><p>补码就是将二进制位的最高位作为符号位，它的权重是 -2^(w -1) （这里的 w 为比特位的个数） ，如果它设置为 1 表示负数，如果设置为 0，表示<strong>非负数</strong>。如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241223155539.png"><br><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241223161344.png"></p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241223211656.png"></p><p>根据补码的定义来看，补码能够表示的最大的数是 2^(w -1) - 1，而它能够表示的最小的的数是 -2^(w -1) （这里的 w 为比特位的个数）。那么最小数的绝对值是比最大数的绝对值还要大 1 的。从上面的图也可以看出（上图中的比特位数为 4），数轴最左侧的刻度是 -8，而数轴最右侧的刻度是 7。 </p><p>对于补码的取反操作是把每个比特位都取反，然后加上 1。为什么补码的取反要这样操作？从数学的角度上讲一个数 x 加上它的取反 -x 的结果应该是 0。从计算机的角度我们可以知道 x 加上 x 的每个比特位取反的结果是<strong>每个比特位都是 1</strong>，按照补码的表示方式就是 10 进制的 -1，然后再加上 1 那就是 0，这样的结果就和数学上是相符合的了。比如假设总的比特位数是 8，1 的补码是 0000_0001，取反之后就是 1111_1110，相加的结果是 1111_1111，即 -1，然后加上 1 就是 0000_0000，即 0。如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241223171030.png"></p><p>补码的英文名字「 <strong>two’s complement</strong>」 这个名字的由来是如果把一个数的补码和它取反的补码得到的二进制都看作是<strong>无符号数</strong>的话，它相加的结果就是 2^w （这里的 w 为比特位的个数）。如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241223170950.png"></p><p>回过头来看 Java 中的 <code>int</code> 类型，它的最小值 <code>Integer.MIN_VALUE</code> 的补码表示形式就是 1000_0000_0000_0000_0000_0000_0000_0000，按照补码取反操作的规则，应该是把它的补码按位取反得到 0111_1111_1111_1111_1111_1111_1111_1111，然后加 1，得到的结果还是 1000_0000_0000_0000_0000_0000_0000_0000，即它自己。因此在 <code>Math.abs()</code> 函数中对 <code>Integer.MIN_VALUE</code> 取反后得到的值仍然是 <code>Integer.MIN_VALUE</code>。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>对于 <code>Integer.MIN_VALUE</code> 的绝对值溢出现象的解决方法有以下几种：</p><p>一种是使用 <code>Math.absExact()</code> 方法，该方法在获取绝对值之前会判断是否超过了表示范围，如果超过了表示范围会抛出一个异常，如下图所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        System.out.println(Math.absExact(Integer.MIN_VALUE));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241222124816.png"></p><p>实现原理其实就是在进入方法时判断了一下是否是 <code>Integer.MIN_VALUE</code> ，如果是就直接抛出异常了，如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241222125319.png"></p><p>也可以转为 <code>long</code> 类型后再获取绝对值，因为 <code>Integer.MIN_VALUE</code> 的绝对值是可以用 <code>long</code> 类型来表示的，因此转为 <code>long</code> 类型来获取绝对值也是可以的，但是这个方法就解决不了 <code>Long.MIN_VALUE</code> 绝对值溢出现象。如下图所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Integer.MIN_VALUE;  </span><br><span class="line">    System.out.println(Math.abs((<span class="type">long</span>) a) &gt;= <span class="number">0</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241223202308.png"></p><p>还有一种可以使用 <code>Integer.MIN_VALUE</code> 构造一个 <code>BigInteger</code> 对象，然后通过获取这个对象的绝对值来和 <code>BigDecimal.ZERO</code> 来比较，这种方式不仅可以解决 <code>Integer.MIN_VALUE</code> 的绝对值溢出问题，还可以解决 <code>Long.MIN_VALUE</code> 的绝对值溢出问题。如下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">    <span class="type">BigInteger</span> <span class="variable">minInt</span> <span class="operator">=</span> BigInteger.valueOf(Integer.MIN_VALUE);  </span><br><span class="line">    System.out.println(minInt.abs().compareTo(BigInteger.ZERO) &gt;= <span class="number">0</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="type">BigInteger</span> <span class="variable">minLong</span> <span class="operator">=</span> BigInteger.valueOf(Long.MIN_VALUE);  </span><br><span class="line">    System.out.println(minLong.abs().compareTo(BigInteger.ZERO) &gt;= <span class="number">0</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241223205122.png"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.15.4">Unary Minus Operator </a><br><a href="https://en.wikipedia.org/wiki/Signed_number_representations#Sign%E2%80%93magnitude">Sign–magnitude</a><br><a href="https://en.wikipedia.org/wiki/Signed_number_representations#Ones'_complement">Ones’ complement</a><br><a href="https://en.wikipedia.org/wiki/Two%27s_complement">Two’s_complement</a><br><a href="https://note.nxcloud.club:12270/blog/post/agile/67fb14439cac">二进制—原码、反码、补码</a><br><a href="https://book.douban.com/subject/25820786/">Computer Organization and Design</a><br><a href="https://m.douban.com/book/subject/26344642/">Computer Systems: A Programmer’s Perspective</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;现象&quot;&gt;&lt;a href=&quot;#现象&quot; class=&quot;headerlink&quot; title=&quot;现象&quot;&gt;&lt;/a&gt;现象&lt;/h2&gt;&lt;p&gt;假如有如下代码定义了一个方法 &lt;code&gt;test()&lt;/code&gt;，它入参可以任何一个 int 类型的整数，那么它输出结果可能是什么？&lt;/</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Windows 10 下编译 64 位 OpenJDK 8 并单步调试</title>
    <link href="http://example.com/2024/12/14/windows-10-xia-bian-yi-64-wei-openjdk-8-bing-dan-bu-diao-shi/"/>
    <id>http://example.com/2024/12/14/windows-10-xia-bian-yi-64-wei-openjdk-8-bing-dan-bu-diao-shi/</id>
    <published>2024-12-14T13:15:04.000Z</published>
    <updated>2024-12-27T01:23:46.305Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Windows-10-下编译-64-位-OpenJDK-8"><a href="#Windows-10-下编译-64-位-OpenJDK-8" class="headerlink" title="Windows 10 下编译 64 位 OpenJDK 8"></a>Windows 10 下编译 64 位 OpenJDK 8</h1><h2 id="软件版本"><a href="#软件版本" class="headerlink" title="软件版本"></a>软件版本</h2><ul><li><p>操作系统：Windows 10<br><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241211110515.png" alt="image.png"></p></li><li><p>Cygwin：3.5.4-1<br><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241211110622.png" alt="image.png"></p></li><li><p>Visual Studio：2010 英文版<br> <img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241212112106.png" alt="image.png"></p></li><li><p>freetype: 2.7<br><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241211112927.png" alt="image.png"></p></li><li><p>Boot JDK：7<br><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241214130139.png" alt="image"></p></li><li><p>编译的 OpenJDK 版本：8<br><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241211111225.png" alt="image.png"></p></li></ul><h2 id="安装-boot-JDK"><a href="#安装-boot-JDK" class="headerlink" title="安装 boot JDK"></a>安装 boot JDK</h2><p>从<a href="https://archive.org/details/jdk-7u80-windows-x64_201809">下载链接</a>下载 JDK，然后在 Windows 上安装。安装完成后配置 <code>JAVE_HOME</code> 环境变量，如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/bootjdk02.png" alt="bootjdk02.png"></p><p>在已有的 Path 环境变量加入 %JAVA_HOME%\bin ，如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/bootjdk03.png" alt="bootjdk03.png"></p><p>配置完成后在 cmd 中执行 <code>java -version</code> 命令，可以看到对应的版本信息，则证明已配置好，如下图所示：<br> <img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241214130139.png" alt="image"></p><h2 id="安装-Cygwin"><a href="#安装-Cygwin" class="headerlink" title="安装 Cygwin"></a>安装 Cygwin</h2><p>从<a href="https://www.cygwin.com/install.html">下载链接</a>下载安装程序，然后在 Windows 上安装。<br>设置安装的路径，这里设置的是 E:\cygwin64，如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/cygwin01.png" alt="cygwin01.png"></p><p>选择要额外安装的命令，包括：<code>binutils</code>，<code>cpio</code>，<code>m4</code>，<code>make</code>，<code>procps-ng</code>，<code>unzip</code>，<code>zip</code>。<br>选择安装 <code>binutils</code> 命令，如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/cygwin02.png" alt="cygwin02.png"></p><p>选择安装 <code>cpio</code> 命令，如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/cygwin03.png" alt="cygwin03.png"></p><p>选择安装 <code>m4</code> 命令，如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/cygwin04.png" alt="cygwin04.png"></p><p>选择安装 <code>make</code> 命令，如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/cygwin05.png"></p><p>选择安装 <code>procps-ng</code> 命令，如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/cygwin06.png" alt="cygwin06.png"></p><p>选择安装 <code>unzip</code> 命令，如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/cygwin07.png" alt="cygwin07.png"></p><p>选择安装 <code>zip</code> 命令，如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/cygwin08.png" alt="cygwin08.png"></p><p>安装完成后在已有的 Path 环境变量加入 E:\cygwin64\bin 路径，如下图所示： </p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241212125610.png" alt="image.png"></p><h2 id="安装-VS-2010"><a href="#安装-VS-2010" class="headerlink" title="安装 VS 2010"></a>安装 VS 2010</h2><p>从<a href="https://archive.org/details/microsoft-visual-studio-2010-ultimate">下载链接</a>下载 VS 2010 英文版（<strong>这里一定要用英文版</strong>），然后在 Windows 上安装。</p><p>安装的时候设置安装路径，<strong>注意路径中不能有空格</strong>，如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/vs01.png" alt="vs01.png"></p><p>安装的特性只需要勾选 Visual C++，如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/vs02.png" alt="vs02.png"></p><p>在已有的 Path 环境变量加入 E:\MicrosoftVisualStudio10.0\VC\bin 路径，如下图所示： </p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241212125931.png" alt="image.png"></p><h2 id="下载并编译-freetype"><a href="#下载并编译-freetype" class="headerlink" title="下载并编译 freetype"></a>下载并编译 freetype</h2><p>从<a href="https://sourceforge.net/projects/freetype/files/freetype2/2.7/">下载链接</a>下载 freetype 源码并解压。</p><p>然后打开 VS 2010，点击 File-&gt;Open-&gt;Project&#x2F;Solution，选择 freetype 解压路径下的 builds\windows\vc2010\freetype.sln 文件并打开，如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/vs03.png" alt="vs03.png"></p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/vs04.png" alt="vs04.png"></p><p>右键后点击 Properties，如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/vs06.png" alt="vs06.png"></p><p><strong>配置编译成静态链接库</strong>，选择 Configuration 为 Release Multithreaded，Platform 选择 x64， Target Name 修改为 freetype，Target Extension 修改为 .lib，Configuration Type 修改为 Static libraty(.lib)，如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/vs07.png" alt="vs07.png"></p><p>点击 Build-&gt; Build Solution 编译静态链接库，编译完成后在 freetype 解压路径下的 objs\vc2010\x64 目录下会生成 freetype.lib 文件，如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241212141006.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/vs09.png"></p><p><strong>配置编译静态链接库</strong>，主要是 Target Extension 修改为 .dll，Configuration Type 修改为 Dynamic Library(.dll)，如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/vs10.png" alt="vs10.png"></p><p>点击 Build-&gt; Build Solution 编译动态链接库，编译完成后在 freetype 解压路径下的 objs\vc2010\x64 目录会生成 freetype.dll 文件，如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/vs11.png" alt="vs11.png"></p><p>然后在 freetype 解压路径下创建 lib 目录，把 freetype.lib 和 freetype.dll 两个文件拷贝到这个 lib 目录下，如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/vs12.png" alt="vs12.png"></p><h2 id="下载并编译OpenJDK-8"><a href="#下载并编译OpenJDK-8" class="headerlink" title="下载并编译OpenJDK 8"></a>下载并编译OpenJDK 8</h2><p>从<a href="https://github.com/openjdk/jdk/archive/refs/tags/jdk8-b120.zip">下载链接</a>下载 OpenJDK 8 的源码并解压。如果你使用的软件版本和本文的软件版本一致，则推荐下载<a href="https://github.com/javadaydayup/jdk8">替换文件</a> 替换到解压后相对应的目录下，不然编译的时候会遇到报错。不一致的话则手动修改解压后的文件，见后面的<a href="#%E7%BC%96%E8%AF%91%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95">编译遇到的问题及解决办法</a>。</p><p>在 OpenJDK 8 的解压路径下执行 <code>./configure --with-freetype=&#39;/cygdrive/e/freetype-2.7&#39; --with-target-bits=64 --enable-debug -disable-ccache</code> 命令，其中 <code>--with-freetype</code> 替换为实际的 freetype 的路径，执行成功后的提示如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241212143101.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/configture01.png" alt="configture01.png"></p><p>然后执行 <code>make all</code> 命令开始编译，等待编译结束，编译成功后会在 OpenJDK 8 解压路径下的build 目录生成 windows-x86_64-normal-server-fastdebug 目录，编译后的 JDK 就在这个目录下，如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241212110757.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241212111252.png" alt="image.png"></p><p>进入到 build\windows-x86_64-normal-server-fastdebug\jdk\bin 目录，执行 <code>java -version</code>，就可以看到输出如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241212111456.png" alt="image.png"></p><p>这个时候就拥有了一个在自己电脑上编译出来的 JDK 8 了。</p><h2 id="编译遇到的问题及解决办法"><a href="#编译遇到的问题及解决办法" class="headerlink" title="编译遇到的问题及解决办法"></a>编译遇到的问题及解决办法</h2><h3 id="Your-cygwin-is-too-old"><a href="#Your-cygwin-is-too-old" class="headerlink" title="Your cygwin is too old"></a>Your cygwin is too old</h3><p>执行 <code>./configure --with-freetype=&#39;/cygdrive/e/freetype-2.7&#39; --with-target-bits=64 --enable-debug -disable-ccache</code> 命令后可能会遇到报错提示： Your cygwin is too old.，如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241211175600.png" alt="image.png"></p><p>这个是因为 OpenJDK 8 解压路径下的 common\autoconf\generated-configure.sh 脚本有 Bug ，这个脚本中把 Cygwin 的版本写死了，确保你的版本大于 1.7 之后，把这里的版本修改为你自己的版本号即可。如果你的版本和本文使用的版本一致，则直接可以下载<a href="https://github.com/javadaydayup/jdk8">替换文件</a>后替换即可，如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241211180059.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241212143623.png" alt="image.png"></p><h3 id="time-is-more-than-10-years-from-present"><a href="#time-is-more-than-10-years-from-present" class="headerlink" title="time is more than 10 years from present"></a>time is more than 10 years from present</h3><p>执行 <code>make all</code> 命令后，可能会遇到报错提示： time is more than 10 years from present，如下图所示： </p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/compileerror01.png" alt="compileerror01.png"></p><p>这个是因为 OpenJDK 8 解压路径下的  jdk\make\src\classes\build\tools\generatecurrencydata\GenerateCurrencyData.java 这个类中校验了不能超过 10 年。可以手动将这里的 10 修改为 100， 或者直接可以下载<a href="https://github.com/javadaydayup/jdk8">替换文件</a>后替换即可。替换完成后执行 <code>make clean</code> 命令清理，然后再执行 <code>make all</code> 命令，如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241211202255.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241211202520.png" alt="image.png"></p><h3 id="images-only"><a href="#images-only" class="headerlink" title="images-only"></a>images-only</h3><p>执行 <code>make all</code> 命令后，可能会遇到报错提示： Main.gmk:136: images-only] Error 2 ，如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241211211737.png" alt="image.png"></p><p>这个是因为 OpenJDK 8 解压路径下的 jdk\make\CreateJars.gmk 文件有两处地方少了回车符号，如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241211212904.png" alt="image.png"></p><p>可以手动给这两处增加回车符号，方法为在 insert 模式下，先按 Ctrl + V ，然后再按 Ctrl + M，或者直接可以下载<a href="https://github.com/javadaydayup/jdk8">替换文件</a>后替换即可。替换完成后执行 <code>make clean</code> 命令清理，然后再执行 <code>make all</code> 命令编译，如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241212094225.png"></p><p>编译成功后输出如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241212110757.png" alt="image.png"></p><h1 id="Windows-10-下单步调试-OpenJDK-8"><a href="#Windows-10-下单步调试-OpenJDK-8" class="headerlink" title="Windows 10 下单步调试 OpenJDK 8"></a>Windows 10 下单步调试 OpenJDK 8</h1><h2 id="创建调试项目"><a href="#创建调试项目" class="headerlink" title="创建调试项目"></a>创建调试项目</h2><p>修改 OpenJDK 8 解压路径下的 hotspot\make\windows\create.bat 脚本中的内容，将脚本中默认的 cygwin64 的安装路径修改为实际的安装路径，如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241212112321.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241212112708.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241212124334.png" alt="image.png"></p><p>进入到 VS 2010 安装路径下的 VC\bin\amd64，执行 <code>vcvars64.bat</code>，执行完成后<strong>不退出这个命令行</strong>，如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241212125200.png" alt="image.png"></p><p>在同一个命令行进入到 OpenJDK 8 解压路径下的 hotspot\make\windows 目录，执行 <code>create.bat E:\jdk-jdk8-b120\jdk</code> 命令创建 VS 2010 项目文件，如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241212131015.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241212131131.png" alt="image.png"></p><h2 id="配置单步调试"><a href="#配置单步调试" class="headerlink" title="配置单步调试"></a>配置单步调试</h2><p>将 OpenJDK 8 解压路径下 build\windows-x86_64-normal-server-fastdebug\jdk\bin\java.diz 解压到所在的路径下，如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241212150003.png" alt="image.png"></p><p>用 VS 2010 打开 OpenJDK 8 解压路径下的 hotspot\build\vs-amd64\jvm.vcxproj 文件，如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241212131354.png" alt="image.png"></p><p>右键后点击 Properties，配置 Debugging 参数，Configuration 选择 compiler2_fastdebug，Platform 选择 x64，Command 配置编译出来的 java.exe ，Command Arguments 增加 -version 参数，这里相当于就是配置执行 <code>java -version</code> 命令，Environment 配置 JAVA_HOME 为编译出来的 JDK 路径，如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241212132446.png" alt="image.png"></p><p>配置完成后，按 F7 重新 build 一下项目，如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241212132620.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241212133827.png" alt="image.png"></p><p>在 OpenJDK 8 解压路径下 share&#x2F;vm&#x2F;runtime&#x2F;arguments.cpp 中的 <code>init_system_properties()</code> 打个断点，如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241212133334.png" alt="image.png"></p><p>点击调试按钮后，代码在断点处停下，如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241212134106.png" alt="image.png"></p><h2 id="单步调试遇到的问题及解决办法"><a href="#单步调试遇到的问题及解决办法" class="headerlink" title="单步调试遇到的问题及解决办法"></a>单步调试遇到的问题及解决办法</h2><h3 id="创建调试项目报错"><a href="#创建调试项目报错" class="headerlink" title="创建调试项目报错"></a>创建调试项目报错</h3><p>执行 <code>create.bat</code> 脚本报如下错误：<br>The code execution cannot proceed because mspdb 100.dll was not found. Reinstalling the program may fix this problem.</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/createproject01.png" alt="createproject01.png"></p><p>是因为没有在同一个命令行执行 <code>vcvars64.bat</code> 见 <a href="#%E5%88%9B%E5%BB%BA%E8%B0%83%E8%AF%95%E9%A1%B9%E7%9B%AE">创建调试项目</a></p><h3 id="单步调试报错"><a href="#单步调试报错" class="headerlink" title="单步调试报错"></a>单步调试报错</h3><p>点击 Debug 按钮启动调试报错如下：<br>‘java.exe’: Loaded ‘E:\openjdk8\openjdk\build\windows-x86_64-normal-server-fastdebug\jdk\bin\java.exe’, Symbols loaded.<br>‘java.exe’: Loaded ‘C:\Windows\System32\ntdll.dll’, Cannot find or open the PDB file<br>‘java.exe’: Loaded ‘C:\Windows\System32\kernel32.dll’, Cannot find or open the PDB file<br>‘java.exe’: Loaded ‘C:\Windows\System32\KernelBase.dll’, Cannot find or open the PDB file<br>‘java.exe’: Loaded ‘C:\Windows\System32\apphelp.dll’, Cannot find or open the PDB file<br>‘java.exe’: Loaded ‘C:\Windows\System32\advapi32.dll’, Cannot find or open the PDB file<br>‘java.exe’: Loaded ‘C:\Windows\System32\msvcrt.dll’, Cannot find or open the PDB file<br>‘java.exe’: Loaded ‘C:\Windows\System32\sechost.dll’, Cannot find or open the PDB file<br>‘java.exe’: Loaded ‘C:\Windows\System32\rpcrt4.dll’, Cannot find or open the PDB file<br>‘java.exe’: Loaded ‘C:\Windows\System32\user32.dll’, Cannot find or open the PDB file<br>‘java.exe’: Loaded ‘C:\Windows\System32\win32u.dll’, Cannot find or open the PDB file<br>‘java.exe’: Loaded ‘C:\Windows\System32\gdi32.dll’, Cannot find or open the PDB file<br>‘java.exe’: Loaded ‘C:\Windows\System32\gdi32full.dll’, Cannot find or open the PDB file<br>‘java.exe’: Loaded ‘C:\Windows\System32\msvcp_win.dll’, Cannot find or open the PDB file<br>‘java.exe’: Loaded ‘C:\Windows\System32\ucrtbase.dll’, Cannot find or open the PDB file<br>‘java.exe’: Loaded ‘C:\Windows\WinSxS\amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.19041.1110_none_60b5254171f9507e\comctl32.dll’, Cannot find or open the PDB file<br>‘java.exe’: Loaded ‘C:\Windows\System32\imm32.dll’, Cannot find or open the PDB file<br>The thread ‘Win64 Thread’ (0x1048) has exited with code 4 (0x4).<br>The thread ‘Win64 Thread’ (0x1efc) has exited with code 4 (0x4).<br>The program ‘[2308] java.exe: Native’ has exited with code 4 (0x4).</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/debug01.png" alt="debug01.png"></p><p>这个需要重新 build 一下项目，见<a href="#%E9%85%8D%E7%BD%AE%E5%8D%95%E6%AD%A5%E8%B0%83%E8%AF%95">配置单步调试</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnblogs.com/jpfss/p/11641045.html#2images_108">Win10下编译OpenJDK8</a><br><a href="https://yfsyfs.github.io/2019/07/11/Windows10%E4%B8%8B%E7%BC%96%E8%AF%91openjdk8/">Windows10下编译openjdk8</a><br><a href="https://blog.csdn.net/u012557298/article/details/135716675">编译openjdk &amp;&amp; 调试java</a><br><a href="https://yfsyfs.github.io/2019/07/11/Windows10%E4%B8%8Bvs2010%E5%8D%95%E6%AD%A5%E8%B0%83%E8%AF%95jvm/">Windows10下vs2010单步调试jvm</a><br><a href="https://blog.csdn.net/LPWSTR/article/details/78840188">Java虚拟机原理分析之Win7下VS2010编译OpenJDK8与单步调试HotSpot VM过程详细记录</a><br><a href="https://github.com/openjdk/jdk8u-dev/blob/master/doc/building.md">building open jdk 8</a>  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Windows-10-下编译-64-位-OpenJDK-8&quot;&gt;&lt;a href=&quot;#Windows-10-下编译-64-位-OpenJDK-8&quot; class=&quot;headerlink&quot; title=&quot;Windows 10 下编译 64 位 OpenJDK 8&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>哪里有 class 告诉我？</title>
    <link href="http://example.com/2024/12/11/na-li-you-class-gao-su-wo/"/>
    <id>http://example.com/2024/12/11/na-li-you-class-gao-su-wo/</id>
    <published>2024-12-11T13:15:04.000Z</published>
    <updated>2024-12-27T01:24:10.819Z</updated>
    
    <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>本文中的 JVM 参数和代码在 JDK 8 版本生效。</p><h2 id="哪里有用户类？"><a href="#哪里有用户类？" class="headerlink" title="哪里有用户类？"></a>哪里有用户类？</h2><p>用户类是由开发者和第三方定义的类，它是由应用程序类加载器加载的。</p><p>Java 程序可以通过<code>CLASSPATH</code> 环境变量，JVM 启动参数 <code>-cp</code> 或者 <code>-classpath</code> 指定用户需要加载的类的路径。这两个配置的优先级从低到高，后面的配置会覆盖前面的配置，默认值是「.」，即当前路径。</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241210155900.png" alt="image.png"></p><p>接下来对默认值和优先级进行验证：</p><h3 id="验证默认值是当前路径"><a href="#验证默认值是当前路径" class="headerlink" title="验证默认值是当前路径"></a>验证默认值是当前路径</h3><p>现在有一个 Temp.java 类，它不在任何包路径下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Temp</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;Executed!&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时这个时候系统没有配置 <code>CLASSPATH</code> 这个环境变量，如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241206204249.png" alt="image.png"></p><p>然后拷贝这个编译后的 <code>Temp.class</code> 文件放到 E 盘的下，然后执行命令 <code>java Temp</code> 命令，是能够正常运行这个 Class 文件的。这个时候并没有配置 <code>CLASSPATH</code> 环境变量，同时也没有在执行命令时指定任何参数，说明类加载器是根据 class path 的默认值去找到这个 Class 文件的，这个默认值就是当前路径。如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241206204511.png" alt="image.png"></p><p>根据<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/findingclasses.html">官方文档</a>所说 Java 程序启动的时候会把 class path 的值放到 <code>java.class.path</code> 这个系统属性中，如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241206211609.png" alt="image.png"></p><p>修改上面的代码，在程序运行的时候把实际的 class path 打印出来，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Temp</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;Executed!&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;The actual class path is :&quot;</span> + System.getProperty(<span class="string">&quot;java.class.path&quot;</span>));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码执行结果如下图所示：<br><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241206212225.png" alt="image.png"></p><p>可以看到代码打印的结果是「.」，即当前路径。</p><h3 id="验证-CLASSPATH-环境变量的作用"><a href="#验证-CLASSPATH-环境变量的作用" class="headerlink" title="验证 CLASSPATH 环境变量的作用"></a>验证 CLASSPATH 环境变量的作用</h3><p>增加 Windows 系统环境变量，因为上面是把 Temp.class 文件放到了 E 盘下面，所以这里设置的 CLASSPATH 环境变量也是 E 盘，如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241206212640.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241206212746.png" alt="image.png"></p><p>再次运行程序，执行结果如下图所示：<br><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241206212916.png" alt="image.png"></p><p>程序能够正常执行说明通过配置的 E: 这个路径，类加载器能够找到 <code>Temp.class</code> 文件。同时打印的 class path 也是 E: ，符合设置。</p><h3 id="验证-cp-或者-classpath-参数的作用"><a href="#验证-cp-或者-classpath-参数的作用" class="headerlink" title="验证 -cp 或者 -classpath 参数的作用"></a>验证 <code>-cp</code> 或者 <code>-classpath</code> 参数的作用</h3><p>把上面设置的 <code>CLASSPATH</code> 环境变量删除，然后通过执行 java 命令的时候指定 <code>-cp</code> 参数来设置 class path 的路径。如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241206204249.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241206213644.png" alt="image.png"></p><p>程序执行的效果和通过 <code>CLASSPATH</code> 环境变量设置的相同。</p><h3 id="验证-cp或-classpath-参数的优先级高于-CLASSPATH-环境变量"><a href="#验证-cp或-classpath-参数的优先级高于-CLASSPATH-环境变量" class="headerlink" title="验证 -cp或 -classpath 参数的优先级高于 CLASSPATH 环境变量"></a>验证 <code>-cp</code>或 <code>-classpath</code> 参数的优先级高于 <code>CLASSPATH</code> 环境变量</h3><p>设置 <code>CLASSPATH</code> 环境变量为 D: ，如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241206213917.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241206214256.png" alt="image.png"></p><p>如果不带 <code>-cp</code> 参数执行执行会提示找不到类，因为 D: 路径下没有 <code>Temp.class</code> 这个文件。如下图所示：<br><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241206214334.png" alt="image.png"></p><p>带上 <code>-cp</code> 参数后就能够正常执行，这个时候两个配置都有，但是 <code>-cp</code> 参数的配置生效了，说明 <code>-cp</code> 参数的优先级高于 <code>CLASSPAHTH</code> 环境变量。如下图所示：<br><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241206214639.png" alt="image.png"></p><h2 id="哪里有引导类？"><a href="#哪里有引导类？" class="headerlink" title="哪里有引导类？"></a>哪里有引导类？</h2><h3 id="sun-boot-class-path-系统属性的值"><a href="#sun-boot-class-path-系统属性的值" class="headerlink" title="sun.boot.class.path 系统属性的值"></a><code>sun.boot.class.path</code> 系统属性的值</h3><p>引导类指的是构成 Java 平台的类，包括 rt.jar 中的类以及其他几个重要的 jar 文件中的类，它们是由引导类加载器（Bootstrap ClassLoader）加载的。</p><p>在前面可以看到如果直接在 <code>Temp.class</code> 文件所在的路径下执行 <code>java Temp</code>命令就能够正常执行。那这个 <code>Temp</code> 类的父类是 <code>Object</code> 类，这个类是在 <code>jre/lib</code> 目录下的 <code>rt.jar</code> 包中，但是没有任何地方指定了这个路径，那引导类加载器（BootstrapClassLoader） 是如何找 Object 类并加载的呢？</p><p>根据<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/findingclasses.html">官方文档</a>说的引导类加载器加载的 class path 可以通过 <code>sun.boot.class.path</code> 这个系统属性获取到，如下图所示：<br><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241206215601.png" alt="image.png"></p><p>把上面的代码修改为如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Temp</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;Executed!&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;The actual class path is :&quot;</span> + System.getProperty(<span class="string">&quot;sun.boot.class.path&quot;</span>));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>java Temp</code> 命令执行后(不配置 <code>CLASSPATH</code> 环境变量，让它使用默认值)，结果如下：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241206220849.png" alt="image.png"></p><p>可以看到输出结果里面有 rt.jar 包的绝对路径。实际上并没有任何地方指定了这个路径，那么这个路径怎么获取到并设置到 <code>sun.boot.class.path</code> 这个系统属性中的呢？</p><h3 id="sun-boot-class-path-系统属性赋值源码分析"><a href="#sun-boot-class-path-系统属性赋值源码分析" class="headerlink" title="sun.boot.class.path 系统属性赋值源码分析"></a><code>sun.boot.class.path</code> 系统属性赋值源码分析</h3><p>这里以 Windows 平台为例分析一下 HotSpot 虚拟机的源码实现。这里主要涉及到三个文件的内容，分别是：<br><code>hotspot\src\share\vm\runtime\arguments.cpp</code><br><code>hotspot\src\share\vm\runtime\os.cpp</code><br><code>hotspot\src\os\windows\vm\os_windows.cpp</code>  </p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241210161105.png" alt="image.png"></p><p>源代码的调用链路如下：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/arguments.jpg" alt="arguments.jpg"></p><p><code>arguments.cpp</code> 负责处理 JVM 启动的参数，在这个文件中会初始化 <code>_java_home</code> 和<code>_sun_boot_class_path</code> 系统属性，如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241210131929.png" alt="image.png"></p><p>然后调用 <code>os_windows.cpp</code> 的 <code>init_system_properties_values()</code> 方法，在该方法中又会调用 <code>os_windows.cpp</code> 中的 <code>jvm_path()</code> 方法，该方法中会尝试去获取 <code>jvm.dll</code> 的绝对路径，如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241210134801.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241210134858.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241210135324.png" alt="image.png"></p><p>然后返回到<code>os_windows.cpp</code> 的 <code>init_system_properties_values()</code> 方法，去除掉路径中的 <code>jvm.dll</code>，<code>server/client</code>，<code>bin</code> 然后放入到前面创建的 <code>_java_home</code> 系统属性中，如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241210135725.png" alt="image.png"></p><p>然后再继续调用 <code>os.cpp</code> 中的 <code>set_boot_path()</code> 方法，在这个方法中获取 <code>_java_home</code> 系统属性中的值，用来格式化引导类 jar 包的路径，然后放入到 <code>_sun_boot_class_path</code> 中。 如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241210140401.png" alt="image.png"></p><p>这就是 <code>sun.boot.class.path</code> 系统属性值在 Java 程序启动时的设置过程。</p><p><a href="https://book.douban.com/subject/34907497/">深入理解Java虚拟机</a>中介绍到「引导类加载器负责加载存放在<JAVA_HOME>&#x2F;lib 目录下或者被 <code>-Xbootclasspath</code> 参数所指定的路径中存放的，且是 Java 虚拟机能够识别的（按照文件名识别，例如 rt.jar，名字不符合的类库即使是放在 lib 目录中也不会被加载）」。这里所描述的「按照文件名识别」指的应该就是上面 <code>os.cpp</code> 的 <code>set_boot_path()</code> 方法中定义的路径常量，只有这些路径常量才会被格式化最终放到 <code>sun.boot.class.path</code> 系统属性中。</p><p>目前这个系统属性在 JDK 9 中已经被移除了，如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241210141521.png" alt="image.png"></p><p>引导类的路径可以通过 <code>sun.boot.class.path</code> 系统属性或者 <code>-Xbootclasspath</code> JVM 参数设置。</p><h3 id="神奇的-Xbootclasspath-p-参数"><a href="#神奇的-Xbootclasspath-p-参数" class="headerlink" title="神奇的 -Xbootclasspath/p 参数"></a>神奇的 <code>-Xbootclasspath/p</code> 参数</h3><p>除此之外 JVM 还提供了两个参数 <code>-Xbootclasspath/p</code> 和 <code>-Xbootclasspath/a</code>，分别用于在默认的引导类路径前面和后面增加所配置的路径。如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241210143824.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241210144019.png" alt="image.png"></p><p><code>-Xbootclasspath/p</code> 这个参数有点意思，它可以用来修复引导类的 Bug 或者扩展类的功能。</p><p>比如现在把 <code>java.util.Collections</code> 类拷贝出来，给它增加一个方法 <code>extendMethod()</code>，然后打包成 jar 包，如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241210144957.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241210145227.png" alt="image.png"></p><p>在代码中通过反射的方式调用 <code>extendMethod()</code> 方法，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Temp</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> Collections.class.getDeclaredMethod(<span class="string">&quot;extendMethod&quot;</span>);  </span><br><span class="line">        method.invoke(<span class="literal">null</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在执行 java 命令时通过 <code>-Xbootclasspath/p</code> 配置上这个 jar 包。可以看到新增的方法被成功调用了，说明 <code>extend.jar</code> 包中的 <code>Collections</code> 类覆盖了默认的 <code>java.util.Collections</code> 类，因为它在所有的路径前面，所以先被类加载器加载。如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241210150221.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241210162035.png" alt="image.png"></p><p>这个参数在 JDK 9 中也被移除了，取而代之的是 <code>--patch-module</code> 参数，如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241210162927.png" alt="image.png"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/findingclasses.html">findingclasses</a><br><a href="https://docs.oracle.com/javase/tutorial/essential/environment/paths.html">PATH and CLASSPATH</a><br><a href="https://www.oracle.com/java/technologies/javase/9-relnotes.html#JSERN9">JDK 9 Release Notes</a><br><a href="http://openjdk.java.net/jeps/261">JEP 261</a><br><a href="https://stackoverflow.com/questions/63420048/how-can-we-overwrite-java-base-java-lang-integer-from-openjdk-11-using-patch-m">How can we overwrite java.base&#x2F;java.lang.Integer from OpenJDK 11 using –patch-module?</a><br><a href="https://book.douban.com/subject/34907497/">深入理解Java虚拟机</a>  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;p&gt;本文中的 JVM 参数和代码在 JDK 8 版本生效。&lt;/p&gt;
&lt;h2 id=&quot;哪里有用户类？&quot;&gt;&lt;a href=&quot;#哪里有用户类？&quot; cl</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>一个 Bug JDK 居然改了十年？</title>
    <link href="http://example.com/2024/12/03/yi-ge-bug-jdk-ju-ran-gai-liao-shi-nian/"/>
    <id>http://example.com/2024/12/03/yi-ge-bug-jdk-ju-ran-gai-liao-shi-nian/</id>
    <published>2024-12-03T13:15:04.000Z</published>
    <updated>2024-12-27T01:24:53.893Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h2><p>今天偶然看到了一个 JDK 的 Bug，给大家分享一下。</p><p>假设现在有如下的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">Object[] array = list.toArray();</span><br><span class="line">array[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">System.out.println(Arrays.toString(array));</span><br></pre></td></tr></table></figure><p>上面的代码是可以正常支执行的，如下图所示：<br><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241201201129.png" alt="image.png"></p><p>修改代码为如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">Object[] array = list.toArray();</span><br><span class="line">array[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">System.out.println(Arrays.toString(array));</span><br></pre></td></tr></table></figure><p>再次执行代码，结果就会抛出 <code>ArrayStoreException</code> 异常，这个异常表明这里并不能把一个 <code>Integer</code> 类型的对象存放到这个数组里面。如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241201201522.png"></p><p>查看 <code>Arrays</code> 的静态内部类 <code>ArrayList</code> 的 <code>toArray()</code> 方法的返回值就是 <code>Object[]</code> 类型的，如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241202182912.png" alt="image.png"></p><p>这里就会引发一个疑问： 为啥使用 <code>java.lang.util.ArrayList</code> 代码就可以正常运行？但是使用 <code>Arrays</code> 的静态内部类 <code>ArrayList</code> 就会报错了？</p><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>首先看下 <code>java.lang.util.ArrayList</code> 类的 <code>toArray()</code> 方法的实现逻辑：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241201202453.png" alt="image.png"><br>从上面可以看出 <code>toArray()</code> 方法是拷贝了一个 <code>ArrayList</code> 内部的数组对象，然后返回的。而 <code>elementData</code> 这个数组在实际初始化的时候，就是 new 了 <code>Object</code> 类型的数组。如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241201202834.png" alt="image.png"></p><p>那么经过拷贝之后返回的还是一个实际类型为<code>Object</code> 类型的数组。既然这里是一个 <code>Object</code> 类型的数组，那么往里面放一个 <code>Integer</code> 类型的数据是合法的，因为 <code>Object</code> 是 <code>Integer</code> 类型的父类。</p><p>然后再看下 <code>Arrays</code> 的静态内部类 <code>ArrayList</code> 的 <code>toArray()</code> 方法的实现逻辑。这里返回的是 <code>a</code> 这个数组的一个克隆。如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241201203748.png" alt="image.png"></p><p>而这个 <code>a</code> 数组声明的类型是 <code>E[]</code>，根据泛型擦除后的原则，这里实际上声明的类型也变成了 <code>Object[]</code>。 如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241201203936.png" alt="image.png"></p><p>那接下来再看看 <code>a</code> 实际的类型是什么？ 由于 <code>Arrays</code> 的静态内部类 <code>ArrayList</code> 的构造函数是包级访问的，因此只能通过 <code>Arrays.asList()</code> 静态方法来构造一个这个对象。如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241201205147.png" alt="image.png"></p><p>而  <code>Arrays.asList()</code> 方法的签名是变长参数类型，这个是 Java 的一个语法糖，实际对应的是一个数组，泛型擦除后就变成了 <code>Object[]</code> 类型。如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241201211402.png" alt="image.png"></p><p>而在代码实际调用处，实际上会 <code>new</code> 一个 <code>String</code> 类型的数组，也就是说 「**<code>a</code> 的实际类型是一个 <code>String</code> 类型的数组**」。 那么 a 调用了 <code>clone()</code> 方法之后返回的类型也是一个 String 类型的数组，克隆嘛，类型一样才叫克隆。如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241201211744.png" alt="image.png"></p><p>经过上面的分析，答案就呼之欲出了。<code>a</code> 的实际类型是一个 <code>String</code> 类型的数组，那么往这个数组里面放一个 <code>Integer</code> 类型的对象那肯定是要报错的。等效代码如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241201212359.png" alt="image.png"></p><h2 id="为什么是个Bug-？"><a href="#为什么是个Bug-？" class="headerlink" title="为什么是个Bug ？"></a>为什么是个Bug ？</h2><p>查看 <code>Collection</code> 接口的方法签名，方法声明明确是要返回的是一个 <code>Object[]</code> 类型的数组，因为方法明确声明了返回的是一个 <code>Object[]</code> 类型的数组，但是实际上在获取到了这个返回值后把它当作一个 <code>Object[]</code> 类型的数组使用某些情况下是不满足语义的。</p><p>同时这里要注意一下，返回的这个数组要是一个 「<strong>安全</strong>」的数组，安全的意思就是「<strong>集合本身不能持有对返回的数组的引用</strong>」，即使集合的内部是用数组实现的，也不能直接把这个内部的数组直接返回。这就是为什么上面两个 <code>toArray()</code> 方法的实现要么是把原有的数组复制了一份，要么是克隆了一份，本质上都是新建了一个数组。如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241202112745.png" alt="image.png"></p><p>在 OpenJDK 的 BugList 官网上很早就有人提出这个问题了，从时间上看至少在 2005 年就已经发现这个 Bug 了，这个 Bug 真正被解决是在 2015 年的时候，整整隔了 10 年时间。花了 10 年时间修这个 Bug，真是十年磨一剑啊！<br><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241201220333.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241202110002.png" alt="image.png"></p><h2 id="如何修正的这个-Bug-？"><a href="#如何修正的这个-Bug-？" class="headerlink" title="如何修正的这个 Bug ？"></a>如何修正的这个 Bug ？</h2><p>JDK 9 中的实现修改为了新建一个 <code>Object</code> 类型的数组，然后把原有数组中的元素拷贝到这个数组里面，然后返回这个 <code>Object</code> 类型的数组，这样的话就和 <code>java.util.ArrayList</code> 类中的实现方法一样了。<br><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241201225411.png" alt="image.png"></p><p>在 <code>java.util.ArrayList</code> 类的入参为 <code>Collection\&lt;? exends E&gt;</code> 类型的构造函数中就涉及到可能调用 <code>Arrays</code> 的静态内部类 <code>ArrayList</code> 的 <code>toArray()</code> 方法，JDK 在实现的时候针对这个 Bug 还做了特殊的处理，不同厂商发行的 JDK 处理方式还有细微的不同。</p><p><strong>Oracel JDK 8 版本的实现方式</strong>：<br><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241201233355.png" alt="image.png"></p><p><strong>Eclipse Temurin Open JDK 8 版本的实现方式</strong>：<br><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241201233811.png" alt="image.png"></p><p>之所以在 <code>java.util.ArrayList</code> 对这个 Bug 做特殊的处理是因为 Sun 公司在当时选择不修复改这个Bug，因为怕修复了之后已有的代码就不能运行了。如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241202110723.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241202110747.png" alt="image.png"></p><p>比如在修复前有如下的代码，这个代码在 JDK 8 版本是可以正常运行的，如下图所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] strings = (String[]) Arrays.asList(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>).toArray();  </span><br><span class="line"><span class="keyword">for</span> (String string : strings) &#123;  </span><br><span class="line">    System.out.println(string);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是如果升级到 JDK 9 版本，就会报 <code>ClassCastException</code> 异常了，如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241202111734.png" alt="image.png"></p><p>因为修复了这个 Bug 之后，编译器并不能告诉你原来的代码存在问题，甚至连新的警告都没有。假设你从 JDK 8 升级到 JDK 9 了，代码也没有改，但是突然功能就用不了，这个时候你想不想骂人，哈哈哈哈。这也许就是 Sun 公司当年不愿意修复这个 Bug 的原因之一了。当然，如果你要问我为什么要升级的话，我会说：你发任你发，我用 Java 8 ！</p><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>阿里巴巴的 <a href="https://github.com/edisonwd/alibaba-Java-development-document/blob/main/%E3%80%8AJava%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%E3%80%8Bv1.5.0%20%E5%8D%8E%E5%B1%B1%E7%89%88.pdf">Java开发手册</a>对 <code>toArray(T[] array)</code> 方法的调用有如下的建议：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241202161319.png" alt="image.png"><br>这里以 <code>java.util.ArrayList</code> 类的源码作为参考，源码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ArrayList 的 toArray() 方法实现：</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (a.length &lt; size)  <span class="comment">// 如果传入的数组的长度小于 size </span></span><br><span class="line">        <span class="comment">// Make a new array of a&#x27;s runtime type, but my contents:  </span></span><br><span class="line">        <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());  </span><br><span class="line">    System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, size);  </span><br><span class="line">    <span class="keyword">if</span> (a.length &gt; size)  </span><br><span class="line">        a[size] = <span class="literal">null</span>;  </span><br><span class="line">    <span class="keyword">return</span> a;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Arrays 的 coypyOf 方法实现：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class="type">int</span> newLength, Class&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>[]&gt; newType) &#123;  </span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span>  </span><br><span class="line">    T[] copy = ((Object)newType == (Object)Object[].class)  </span><br><span class="line">        ? (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[newLength]  </span><br><span class="line">        : (T[]) Array.newInstance(newType.getComponentType(), newLength);  </span><br><span class="line">    System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,  </span><br><span class="line">                     Math.min(original.length, newLength));  </span><br><span class="line">    <span class="keyword">return</span> copy;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用 <code>toArray()</code> 方法时传入的数组长度为 0 时，方法内部会根据传入的数组类型动态创建一个和当前集合 size 相同的数组，然后把集合的元素复制到这个数组里面，然后返回。</p><p>当调用 <code>toArray()</code> 方法时传入的数组长度大于 0，小于 <code>ArrayList</code> 的 size 时，走的逻辑和上面是一样的，也会进入到 <code>Arays</code> 的 <code>copyOf</code> 方法的调用中，但是调用方法传入的新建的数组相当于新建之后没有被使用，白白浪费了，需要等待 GC 回收。</p><p>当调用 <code>toArray()</code> 方法时传入的数组长度大于等于 <code>ArrayList</code> 的 size 时，则会直接把集合的元素拷贝到这个数组中。如果是大于的情况，还会把数组中下标为 <code>size</code> 的元素设置为 null，但是 <code>size</code> 下标后面的元素保持不变。如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">list.add(<span class="string">&quot;1&quot;</span>);  </span><br><span class="line">String[] array = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">3</span>];  </span><br><span class="line">array[<span class="number">1</span>] = <span class="string">&quot;2&quot;</span>;  </span><br><span class="line">array[<span class="number">2</span>] = <span class="string">&quot;3&quot;</span>;  </span><br><span class="line">String[] toArray = list.toArray(array);  </span><br><span class="line">System.out.println(array == toArray);  </span><br><span class="line">System.out.println(Arrays.toString(toArray));</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241202180440.png" alt="image.png"></p><p>手册中提到的在高并发的情况下，传入的数组长度等于 <code>ArrayList</code> 的 size 时，如果 ArrayList 的 size  在数组创建完成后变大了，还是会走到重新新建数组的逻辑里面，仍然会导致调用方法传入的新建的数组没有被使用，而且这里因为调用方法时新建的数组和 <code>ArrayList</code> 之前的 size 相同，会造成比传入长度为 0 的数组浪费多得多的空间。但是我个人觉得，因为 <code>ArrayList</code> 不是线程安全的，如果存在数据竞争的情况就不应该使用。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://bugs.openjdk.org/browse/JDK-6260652">Arrays.asList(x).toArray().getClass() should be Object[].class</a><br><a href="https://stackoverflow.com/questions/51372788/array-cast-java-8-vs-java-9">array cast Java 8 vs Java 9</a><br><a href="https://juejin.cn/post/6844904034076377095">toArray方法的小陷阱，写开发手册的大佬也未能幸免</a><br> <a href="https://stackoverflow.com/questions/174093/toarraynew-myclass0-or-toarraynew-myclassmylist-size">.toArray(new MyClass[0]) or .toArray(new MyClass[myList.size()])?</a><br><a href="https://shipilev.net/blog/2016/arrays-wisdom-ancients/">Arrays of Wisdom of the Ancients</a><br><a href="https://github.com/alibaba/p3c/blob/master/Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C(%E9%BB%84%E5%B1%B1%E7%89%88).pdf">Java开发手册(黄山版).pdf</a>  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题现象&quot;&gt;&lt;a href=&quot;#问题现象&quot; class=&quot;headerlink&quot; title=&quot;问题现象&quot;&gt;&lt;/a&gt;问题现象&lt;/h2&gt;&lt;p&gt;今天偶然看到了一个 JDK 的 Bug，给大家分享一下。&lt;/p&gt;
&lt;p&gt;假设现在有如下的代码：&lt;/p&gt;
&lt;figure cl</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>这就是 Java 的泛型！</title>
    <link href="http://example.com/2024/11/30/zhe-jiu-shi-java-de-fan-xing/"/>
    <id>http://example.com/2024/11/30/zhe-jiu-shi-java-de-fan-xing/</id>
    <published>2024-11-30T13:15:04.000Z</published>
    <updated>2024-12-27T01:25:17.089Z</updated>
    
    <content type="html"><![CDATA[<h2 id="泛型的定义"><a href="#泛型的定义" class="headerlink" title="泛型的定义"></a>泛型的定义</h2><h3 id="泛型类的定义"><a href="#泛型类的定义" class="headerlink" title="泛型类的定义"></a>泛型类的定义</h3><p>下面定义了一个泛型类 <code>Pair</code>，它有一个泛型参数 <code>T</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">private</span> T start;</span><br><span class="line"><span class="keyword">private</span> T end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际使用的时候就可以给这个 <code>T</code> 指定任何实际的类型，比如下面所示，就指定了实际类型为 <code>LocalDate</code>，泛型给了我们一个错觉就是通过个这个模板类 <code>Pair&lt;T\&gt;</code>，我们可以在实际使用的时候动态的派生出各种实际的类型，比如这里的 <code>Pair&lt;LocalDate\&gt;</code> 类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;LocalDate&gt; period = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><h3 id="泛型类的继承"><a href="#泛型类的继承" class="headerlink" title="泛型类的继承"></a>泛型类的继承</h3><p><strong>子类是一个泛型类</strong>的定义方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Interval</span>&lt;T&gt; extend Pair&lt;T&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>Interval&lt;T\&gt;</code> 类是一个泛型类，也可以像上面使用 <code>Pair&lt;T\&gt;</code> 类一样给它指定实际的类型。</p><p><strong>子类是一个具体类</strong>的定义方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateInterval</span> <span class="keyword">extends</span> <span class="title class_">Pair</span>&lt;LocalDate&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>DateInterval</code> 类就是一个具体的类，而不再是一个泛型类了。这里的语义是 <code>DateInteral</code> 类继承了 <code>Pair&lt;LocalDate\&gt;</code> 类，这里的 <code>Pair&lt;LocalDate\&gt;</code> 类也是一个具体类。但是由于 Java 的泛型实现机制，这里会带来多态上的一个问题，见下面的分析。</p><p>而像下面的这种定义具体类的写法是错误的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateInterval</span>&lt;LocalDate&gt; <span class="keyword">extends</span> <span class="title class_">Pair</span>&lt;LocalDate&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型方法的定义"><a href="#泛型方法的定义" class="headerlink" title="泛型方法的定义"></a>泛型方法的定义</h3><p>泛型方法定义时，类型变量放在修饰符的后面，返回值的前面。泛型方法既可以泛型类中定义，在普通类中定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">genericMethod</span><span class="params">(T a)</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>这里顺便记录一下，因为是使用擦除来实现的泛型，因此字节码中的方法的签名是不会包含泛型信息的。对于泛型方法会多生成一个 Signature 的属性，用于记录方法带泛型信息的签名，反编译器也可以根据这个信息将泛型方法还原回来。<br><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241130185506.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241130185619.png" alt="image.png"></p><h3 id="构造函数泛型"><a href="#构造函数泛型" class="headerlink" title="构造函数泛型"></a>构造函数泛型</h3><p>下面的代码定义了一个泛型类 <code>ConstructorGeneric</code>，它的泛型参数是 <code>T</code>，这个类的构造函数也是泛型的，它有一个泛型参数 <code>X</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConstructorGeneric</span>&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span> &lt;X&gt; ConstructorGeneric(X a) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建该对象的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConstructorGeneric&lt;Number&gt; t = <span class="keyword">new</span> &lt;String&gt;ConstructorGeneric&lt;Number&gt;(<span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure><p>这里 <code>new</code> 后面的 <code>String</code> 是传给构造器的泛型 <code>X</code> 的，即 <code>X</code> 的实际类型为 <code>String</code>；类的范型参数是由 <code>Number</code> 传递的，即 <code>T</code> 的实际类型是 <code>Number</code>。这里两个都是省略，写在这里是为了显示区分出两个参数传递的位置。</p><h3 id="类型变量的限定"><a href="#类型变量的限定" class="headerlink" title="类型变量的限定"></a>类型变量的限定</h3><p><strong>带单个上界限定</strong>：<br>下面的代码定义了一个 <code>NatualNumber</code> 类，它的泛型参数 <code>T</code> 限制为 <code>Integer</code> 或者 <code>Integer</code> 的子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NaturalNumber</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Integer</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NaturalNumber</span><span class="params">(T n)</span>  &#123; <span class="built_in">this</span>.n = n; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEven</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n.intValue() % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常</span></span><br><span class="line">NaturalNumber&lt;Integer&gt; natural1 = <span class="keyword">new</span> <span class="title class_">NaturalNumber</span>&lt;&gt;(<span class="number">1</span>);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 无法编译，因为这里和泛型类定义的上界不符合</span></span><br><span class="line">NaturalNumber&lt;Double&gt; natualral2 = <span class="keyword">new</span> <span class="title class_">NaturalNumber</span>&lt;&gt;(<span class="number">1.0</span>);</span><br></pre></td></tr></table></figure><p> <strong>带多个上界的限定</strong>：<br> 多个上界之间使用 <code>&amp;</code> 符号进行分隔，如果多个限定中有类，则类需要排在接口后面（因为 Java 不支持多继承，所以不存在有多个限定的类的情况）。使用时需要满足所有的限定条件才能执行，<strong>这个校验应该是在编译时期做的</strong>，因为擦除之后，只会保留第一个限定界。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">B</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">B</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">A</span> &amp; B&gt; <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(T a)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">// 编译错误，A 只能满足一个上界</span></span><br><span class="line">test(<span class="keyword">new</span> <span class="title class_">A</span>());</span><br><span class="line"><span class="comment">// 正常</span></span><br><span class="line">test(<span class="keyword">new</span> <span class="title class_">C</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><p>在泛型中使用 <code>?</code> 表示通配符，它的语义是表示未知的类型。通配符可以用作方法的形参、字段的定义、局部变量的定义，以及有的时候作为函数的返回值。通配符不能作为实参调用泛型方法，不能创建对象，或者派生子类型。</p><h3 id="上界通配符"><a href="#上界通配符" class="headerlink" title="上界通配符"></a>上界通配符</h3><p>当你想定义一个普通方法，这个普通方法可以处理某一类的 List 中的元素时，比如像：<code>List&lt;Number\&gt;</code>，<code>List&lt;Integer\&gt;</code>，<code>List&lt;Double\&gt;</code> 时，这个时候如果你把方法的入参定义为 <code>List&lt;Number\&gt;</code> 是不行的，因为在 Java 中 <code>List&lt;Integer\&gt;</code> 不是 <code>List&lt;Number\&gt;</code> 的子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(List&lt;Number&gt; numbers)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译错误</span></span><br><span class="line">List&lt;Number&gt; numbers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">proess(numbers);</span><br></pre></td></tr></table></figure><p>假设 List&lt;Integer&gt; 是 List&lt;Number&gt; 的子类，则可以实现如下的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; integers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设下面是成立的</span></span><br><span class="line">List&lt;Number&gt; numbers = integers;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面这句也应该是合法的，但是这违背了 intergers 只能存放 Integer 的语义</span></span><br><span class="line">numbers.add(<span class="keyword">new</span> <span class="title class_">Double</span>());</span><br></pre></td></tr></table></figure><p>从上面的例子可以看出，如果允许 <code>List&lt;Integer\&gt;</code> 是 <code>List&lt;Number\&gt;</code> 的子类型，则会破坏泛型的语义，因此这在 Java 中是不允许的。</p><p>但是又实际存在上面描述的这种需求，因此 Java 提供了上界通配符的语法，则方法定义可以定义为如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(List&lt;? extends Number&gt; numbers)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (Number num : numbers) &#123;</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的调用都是能够正常编译通过的</span></span><br><span class="line">List&lt;Number&gt; numbers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">process(numbers);</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; integers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">process(integers);</span><br><span class="line"></span><br><span class="line">List&lt;Double&gt; doubles = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">process(doubles);</span><br></pre></td></tr></table></figure><p>这里的 <code>? extends Number</code> 的语义就是可以匹配 <code>Number</code> 或者 <code>Number</code> 子类的 <code>List</code>，需要注意的是在 Java 中的继承（<code>extends</code>）和实现（<code>implements</code>）在这里都用关键字 <code>extends</code> 来表示。</p><p>从这里也可以看出，<code>List\&lt;? extends Number&gt;</code> 的返回值是可以赋值给 <code>Number</code> 类型的。这里可以想象一下 <code>List</code> 的 <code>get()</code> 方法的泛型参数 <code>E</code> 就变成了<code> ? extends Number</code> 这个实际类型，而它表达的语义是 <code>Number</code> 以及 <code>Number</code> 的子类，因此赋值给一个 <code>Number</code> 类型的变量是合法的。</p><p>但是下面的代码是不合法的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(List&lt;? extends Number&gt; numbers)</span> &#123;</span><br><span class="line">numbers.add(<span class="keyword">new</span> <span class="title class_">Integer</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里同样可以想象一下 <code>List</code> 的 <code>add()</code> 方法的入参的泛型参数 <code>E</code> 就变成了 <code>? extends Number</code> 这个实际类型，它表达的语义是 <code>Number</code> 以及 <code>Number</code> 的子类，但是具体是哪个子类是无法确定的。上面的例子也解释了它可能是 <code>Number</code>，<code>Integer</code>，<code>Double</code> 等，假设它是 <code>Double</code> 类型，这里放一个 <code>Integer</code> 类型，又违背了泛型只能放 <code>Double</code> 的语义，因此这里的赋值是不合法的。</p><h3 id="无界通配符"><a href="#无界通配符" class="headerlink" title="无界通配符"></a>无界通配符</h3><p>下面的代码就是定义了一个 <code>List\&lt;?&gt;</code> 形参的方法，这里的 <code>List\&lt;?&gt;</code> 语义是一个未知类型的 <code>List</code>。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printList</span><span class="params">(List&lt;?&gt; list)</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>无界通配符定义的 <code>List</code> 里面的元素只能赋值给 <code>Object</code> 类型。这里可以想象一下 <code>List</code> 的 <code>get()</code> 方法的泛型参数 <code>E</code> 就变成了 <code>?</code> 这个实际类型，它的语义是一个未知的类型，既然是一个未知的类型那么我只能赋值给 <code>Object</code> 类型的变量了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printList</span><span class="params">(List&lt;?&gt; list)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (Object obj : list) &#123;</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无界通配符定义的 <code>List</code> 里面只能添加 <code>null</code>，不能添加其它的任何类型的元素，即使是 <code>Object</code> 也不行，因为添加了之后就会违背泛型的语义了。</p><p>无界通配符的主要使用场景是：</p><ul><li>需要使用 <code>Object</code> 类中的方法</li><li>使用了泛型类中不用关心泛型的方法，比如 <code>List</code> 中的 <code>size()</code> ，<code>clear()</code> 方法</li></ul><h3 id="下界通配符"><a href="#下界通配符" class="headerlink" title="下界通配符"></a>下界通配符</h3><p>在使用上面的上界通配时，发现了一个问题，如果一个 <code>List</code> 类型形参声明为了上界通配符，是没有办法往这个 <code>List</code> 里面添加元素的，为了解决这个问题，可以使用下界通配符，可以定义如下的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addNumbers</span><span class="params">(List&lt;? <span class="built_in">super</span> Number&gt; list)</span> &#123;</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Integer</span>());</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Double</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以想象一下这个时候 <code>List</code> 的 <code>add()</code> 方法的入参的泛型参数 <code>E</code> 就变成了 <code>? super Integer</code> 类型，它的语义是匹配 <code>Number</code> 以及 <code>Number</code> 类型的超类。根据 Java 多态的原理，这里实际可以传递的类型为 <code>Integer</code> 以及 <code>Integer</code> 的子类型，因为形参声明的是超类，实际传递子类的引用当然是合法的。</p><h2 id="泛型继承关系"><a href="#泛型继承关系" class="headerlink" title="泛型继承关系"></a>泛型继承关系</h2><p>泛型的继承关系如下图所示：</p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241129111245.png" alt="image.png"></p><h2 id="通配符捕获"><a href="#通配符捕获" class="headerlink" title="通配符捕获"></a>通配符捕获</h2><p>假设定义了一个无界限通配符的方法如下，这个方法会编译错误，因为按照之前分析的 <code>List\&lt;?&gt;</code> 中不能添加任何类型的对象，而这里 <code>list.get(0)</code> 返回的是 <code>Object</code> 类型的对象，肯定是无法放入进去的。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(List&lt;?&gt; list)</span> &#123;</span><br><span class="line">list.set(<span class="number">0</span>, list.get(<span class="number">0</span>)); <span class="comment">// 编译报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了解决这个问题这个时候就可以通过新建一个私有的泛型方法来帮助捕获通配符的类型，这个私有的泛型方法名称通常是原有方法加上Helper后缀，这种技巧称为<strong>通配符捕获</strong>。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pulic <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(List&lt;?&gt; list)</span> &#123;</span><br><span class="line"><span class="comment">// 调用这个方法的语义是告诉编译器我不知道具体类型是什么，</span></span><br><span class="line"><span class="comment">// 但是取出来和放进去的元素类型是相同的</span></span><br><span class="line">fooHelper(list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">fooHelper</span><span class="params">(List&lt;T&gt; list)</span> &#123;</span><br><span class="line">    <span class="comment">// 合法</span></span><br><span class="line"><span class="type">T</span> <span class="variable">temp</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 合法</span></span><br><span class="line">list.set(<span class="number">0</span>, temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于泛型方法，因为 <code>add()</code> 方法的入参，<code>get()</code> 方法返回值的泛型参数都是 <code>T</code>，当传入一个 <code>List</code> 进来，虽然这个 <code>List</code> 里面的对象实际类型不知道，但是通过泛型参数可以判断 <code>get()</code> 方法返回类型和 <code>add()</code> 方法的入参类型都是一样的，都是 T 捕获到的一个实际类型 <code>X</code>。</p><p>对于带通配符参数的方法，因为方法的声明没有一个泛型参数，不能捕获到实际的参数类型 <code>X</code>。那么对于<strong>每次方法的调用</strong>编译器都会认为是一个不同的类型。比如编译器编译的时候 <code>list.set(0, xxx)</code>，这里的入参的类型就会是 <code>CAP#1</code>， <code>list.get(0)</code> 返回的类型就是 <code>CAP#2</code>，因为没有一个泛型参数来告诉编译器说 <code>CAP#1</code> 和 <code>CAP#2</code> 是一样的类型，因此编译器就会认为这两个是不同的类型，从而拒绝编译。下图是编译器实际的提示信息：<br><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241130164803.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241130164915.png" alt="image.png"><br>从上面的图也可以看出，第二次调用方法时，类型又变成 <code>CAP#3</code> 和 <code>CAP#4</code> 了，这也证明了每次编译器都会认为是一个新的类型。</p><p>实际上这里也可以将这个私有的 Helper 方法定义为公共的，然后去掉通配符的方法。这两种定义实际上是达到了相同的效果，但是 Java 语言规范 5.1.10 章节中更推荐采用通配符的方式定义，但它上面阐述的原因没太看懂，但是在另外一篇博客里面看到一个观点感觉有点道理。<br><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241130170304.png" alt="image.png"></p><p>它说如果定义成一个泛型方法，那么老的遗留的没有用泛型的代码调用这个方法就会产生一个警告，但是如果是使用通配符则不会有警告产生。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">foo1</span><span class="params">(List&lt;?&gt;)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">foo2</span><span class="params">(List&lt;T&gt;)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设老的代码没有用泛型</span></span><br><span class="line"><span class="type">List</span> <span class="variable">rawList</span> <span class="operator">=</span> Arrays.asList(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line"><span class="comment">// 不会产生告警</span></span><br><span class="line">foo1(rawList);</span><br><span class="line"><span class="comment">// 会产生告警，提示未经检查的转换</span></span><br><span class="line">foo2(rawList);</span><br></pre></td></tr></table></figure><p>然而实际上 JDK 中真正的实现并没有采用这种方式，而是直接用注解忽略了异常，直接用的原生类型来实现的。<code>Collections</code> 中的 <code>reverse()</code> 方法内部实现逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(List&lt;?&gt; list)</span> &#123;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.size();  </span><br><span class="line">    <span class="keyword">if</span> (size &lt; REVERSE_THRESHOLD || list <span class="keyword">instanceof</span> RandomAccess) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>, mid=size&gt;&gt;<span class="number">1</span>, j=size-<span class="number">1</span>; i&lt;mid; i++, j--)  </span><br><span class="line">            swap(list, i, j);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="comment">// instead of using a raw type here, it&#x27;s possible to capture </span></span><br><span class="line">        <span class="comment">// the wildcard but it will require a call to a supplementary         // private method </span></span><br><span class="line">        <span class="type">ListIterator</span> <span class="variable">fwd</span> <span class="operator">=</span> list.listIterator();  </span><br><span class="line">        <span class="type">ListIterator</span> <span class="variable">rev</span> <span class="operator">=</span> list.listIterator(size);  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>, mid=list.size()&gt;&gt;<span class="number">1</span>; i&lt;mid; i++) &#123;  </span><br><span class="line">            <span class="type">Object</span> <span class="variable">tmp</span> <span class="operator">=</span> fwd.next();  </span><br><span class="line">            fwd.set(rev.previous());  </span><br><span class="line">            rev.set(tmp);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通配符和泛型方法的区别（私有）"><a href="#通配符和泛型方法的区别（私有）" class="headerlink" title="通配符和泛型方法的区别（私有）"></a>通配符和泛型方法的区别（私有）</h2><p>泛型方法是类型没有确定的，实际的类型由使用者设置；<br>通配符是类型确定了的，只是确定的类型可能是一系列的类型，所以使用通配来表示；</p><h2 id="桥接方法"><a href="#桥接方法" class="headerlink" title="桥接方法"></a>桥接方法</h2><p>假设定义了如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> T data;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(T data)</span> &#123; <span class="built_in">this</span>.data = data; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(T data)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Node.setData&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyNode</span> <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyNode</span><span class="params">(Integer data)</span> &#123; <span class="built_in">super</span>(data); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(Integer data)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyNode.setData&quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.setData(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型擦除后的实际代码如下，注意看 MyNode 里面的 <code>setData()</code> 方法并没有重写 Node 里面的 <code>setData()</code> 方法了，因为方法签名不一样。这就违背了 Java 多态的语义。<br>Java 编译器在编译的时候会自动给 MyNode 生成一个桥接方法，这个方法的签名和 <code>Node</code> 类里面的一样，然后在这个方法里面去调用真正的 <code>setData()</code> 方法。<br>通过查看 MyNode.class 文件可以看到真的有两个 <code>setData()</code> 方法存在。<br><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241130172612.png" alt="image.png"></p><p>方法的形参类型是 <code>Object</code> 类型，和 <code>Node</code> 类中泛型擦除后的类型相同，说明这个方法才是真正重载了 <code>Node</code> 类中的方法。<br><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241130173040.png" alt="image.png"></p><p>方法实现中调用了 <code>MyNode</code> 类中形参为 <code>Integer</code> 类型的 <code>setData()</code> 方法。<br><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241130173228.png" alt="image.png"></p><p>同时在 <code>MyNode</code> 类中不允许自己定义形参为 <code>Object</code> 类型的 <code>setData()</code> 方法了，如果定义了则无法编译：<br><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241130173712.png" alt="image.png"></p><p>经过编译器编译后的代码等效为如下的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Object data;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Object data)</span> &#123; <span class="built_in">this</span>.data = data; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(Object data)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Node.setData&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyNode</span> <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyNode</span><span class="params">(Integer data)</span> &#123; <span class="built_in">super</span>(data); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(Integer data)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyNode.setData&quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.setData(data);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 由编译器生成的桥接方法</span></span><br><span class="line">    <span class="comment">// 如果手动定义了这个方法编译器就会报错了</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(Object data)</span> &#123;</span><br><span class="line">        setData((Integer) data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型的局限性"><a href="#泛型的局限性" class="headerlink" title="泛型的局限性"></a>泛型的局限性</h2><h3 id="泛型不能用于基本类型"><a href="#泛型不能用于基本类型" class="headerlink" title="泛型不能用于基本类型"></a>泛型不能用于基本类型</h3><p>泛型是通过擦除实现的，擦除之后 <code>ArrayList</code> 内部是 <code>Object[]</code> 类型的数组，是不能存放基本类型的，因为基本类型不是 <code>Object</code> 类型的子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="type">int</span>&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><h3 id="不能创建泛型类型的实例"><a href="#不能创建泛型类型的实例" class="headerlink" title="不能创建泛型类型的实例"></a>不能创建泛型类型的实例</h3><p>泛型是通过擦除来实现的，所以擦除之后都会变成 <code>new Object()</code> (没有指定上界的情况)，而实际上我们是要创建 <code>T</code> 类型的实例的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(List&lt;T&gt; list)</span> &#123;</span><br><span class="line"><span class="type">E</span> <span class="variable">ele</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">E</span>();</span><br><span class="line">list.add(ele);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以通过如下方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(List&lt;T&gt; list, Class&lt;T&gt; clazz)</span> &#123;</span><br><span class="line"><span class="type">E</span> <span class="variable">ele</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">list.add(ele);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">test(list, String.class);</span><br></pre></td></tr></table></figure><h3 id="不能声明静态的泛型变量"><a href="#不能声明静态的泛型变量" class="headerlink" title="不能声明静态的泛型变量"></a>不能声明静态的泛型变量</h3><p>泛型相当于是类的工厂，可以创建不同类型的实例。而静态变量是所有实例共享的，如果允许声明静态的泛型变量，那么不同类型的实例之间就会存在矛盾。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MobileDevice</span>&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> T os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这两个实例的静态变量就会存在矛盾</span></span><br><span class="line">MobileDevice&lt;Smartphone&gt; phone = <span class="keyword">new</span> <span class="title class_">MobileDevice</span>&lt;&gt;();</span><br><span class="line">MobileDevice&lt;TabletPC&gt; pc = <span class="keyword">new</span> <span class="title class_">MobileDevice</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><h3 id="不能使用-instanceof-判断泛型类型"><a href="#不能使用-instanceof-判断泛型类型" class="headerlink" title="不能使用 instanceof 判断泛型类型"></a>不能使用 instanceof 判断泛型类型</h3><p>泛型是通过擦除实现的，因此 <code>List&lt;\T&gt;.class</code> 在内存中是不存在的，只有 <code>List.class</code>，这个类型也被称为原生类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">if</span> (list <span class="keyword">instanceof</span> List&lt;String&gt;) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">if</span> (list <span class="keyword">instanceof</span> List) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不能创建泛型数组"><a href="#不能创建泛型数组" class="headerlink" title="不能创建泛型数组"></a>不能创建泛型数组</h3><p>泛型是通过擦除实现的，如果允许声明泛型数组，则无法实现数组在存放时会校验数组的元素类型这个语义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设允许创建，这个数组的每个元素只允许存放 List&lt;String&gt; 类型的元素</span></span><br><span class="line">Object[] stringLists = <span class="keyword">new</span> <span class="title class_">List</span>&lt;String&gt;[<span class="number">2</span>]; </span><br><span class="line"><span class="comment">// 正确执行</span></span><br><span class="line">stringLists[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(); </span><br><span class="line"><span class="comment">// 这行应该抛出 ArrayStoreException 异常，</span></span><br><span class="line"><span class="comment">// 但是由于擦除，实际上和上面是一样的，这里违背了数组的语义</span></span><br><span class="line">stringLists[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br></pre></td></tr></table></figure><h3 id="不能创建、捕获、抛出带泛型的异常"><a href="#不能创建、捕获、抛出带泛型的异常" class="headerlink" title="不能创建、捕获、抛出带泛型的异常"></a>不能创建、捕获、抛出带泛型的异常</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译报错</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MathException</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;&#125;    </span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译报错</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QueueFullException</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Throwable</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译报错</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Exception</span>, J&gt; <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(List&lt;J&gt; jobs)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (J job : jobs)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (T e) &#123;  <span class="comment">// 编译报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parser</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Exception</span>&gt; &#123;</span><br><span class="line"><span class="comment">// 这样是允许的</span></span><br><span class="line"><span class="comment">// 我觉得允许的原因是声明了抛出父类，而实际抛出子类也是合法的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parse</span><span class="params">(File file)</span> <span class="keyword">throws</span> T &#123;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不能使用擦除后原生类型相同的泛型参数方法来重载"><a href="#不能使用擦除后原生类型相同的泛型参数方法来重载" class="headerlink" title="不能使用擦除后原生类型相同的泛型参数方法来重载"></a>不能使用擦除后原生类型相同的泛型参数方法来重载</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="comment">// 这两个方法擦除后的参数是一样的，所以不能算重载</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(Set&lt;String&gt; strSet)</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(Set&lt;Integer&gt; intSet)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆污染"><a href="#堆污染" class="headerlink" title="堆污染"></a>堆污染</h2><p>当定义变长的泛型参数时，如果尝试把一个原生类型赋值给变成泛型参数就有可能发生堆污染。堆污染的本质原因就是可以通过语法糖变长参数列表来创建泛型的的数组导致的。例如下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayBuilder</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">addToList</span> <span class="params">(List&lt;T&gt; listArg, T... elements)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (T x : elements) &#123;</span><br><span class="line">      listArg.add(x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">faultyMethod</span><span class="params">(List&lt;String&gt;... l)</span> &#123;</span><br><span class="line">    <span class="comment">// 这里编译应该会有告警，如果忽略这个告警，则有可能带来堆污染</span></span><br><span class="line">    Object[] objectArray = l;   </span><br><span class="line">    objectArray[<span class="number">0</span>] = Arrays.asList(<span class="number">42</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> l[<span class="number">0</span>].get(<span class="number">0</span>);     </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译告警中就会提示有堆污染，如下图所示：<br><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241130174357.png" alt="image.png"></p><p>当编译器遇到一个变长参数方法时，它会把它转换为一个数组。对于 <code>T... elements</code> 这种参数声明就会转为 <code>T[] elements</code>，因为泛型的擦除，最终会被转换为 <code>Object[] elements</code>。<br><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241201210738.png" alt="image.png"><br>编译器在调用出会生成一个实际类型的数组，然后传递给一个类型为 Object[] 的形参，这里发生了不安全的转换，因此编译器会提示堆污染。<br><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241201210903.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241201210946.png" alt="image.png"></p><p>可以通过以下三种方式抑制这种警告：</p><ul><li><code>@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;varargs&quot;&#125;)</code><br> 这种方式只能抑制方法声明时候的告警，方法调用处还是会产生告警；<br> <img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241130183813.png" alt="image.png"></li><li><code>@SafeVarargs</code><br> 不会产生任何警告<br> <img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241130183924.png" alt="image.png"></li><li>增加 <code>-Xlint:varags</code> 编译选项<br>不会产生任何警告<br><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241130184045.png" alt="image.png"></li></ul><h2 id="JVM-控制参数"><a href="#JVM-控制参数" class="headerlink" title="JVM 控制参数"></a>JVM 控制参数</h2><h3 id="显示所有告警信息"><a href="#显示所有告警信息" class="headerlink" title="显示所有告警信息"></a>显示所有告警信息</h3><p>给编译器增加 <code>-Xlint:unchecked</code> ，在 Idea 中可以参考如下图配置：<br><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241129114722.png" alt="image.png"></p><h3 id="显示更详细的诊断信息"><a href="#显示更详细的诊断信息" class="headerlink" title="显示更详细的诊断信息"></a>显示更详细的诊断信息</h3><p>给编译增加 <code>-Xdiags: verbose</code> 选项<br><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241130161952.png" alt="image.png"></p><h3 id="显示所有告警信息为英文"><a href="#显示所有告警信息为英文" class="headerlink" title="显示所有告警信息为英文"></a>显示所有告警信息为英文</h3><p>增加如下环境变量：<br><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241129114833.png" alt="image.png"><br>Idea 中可以将配置放在 vmproperties 文件中，如下图所示：<br><img src="https://raw.githubusercontent.com/javadaydayup/pictures/main/20241129115120.png" alt="image.png"></p><h2 id="通配符和类型限定的区别（私有）"><a href="#通配符和类型限定的区别（私有）" class="headerlink" title="通配符和类型限定的区别（私有）"></a>通配符和类型限定的区别（私有）</h2><p>通配符只能绑定一个上界或者下界，但是类型限定可以绑定多个；<br>通配符无法用于直接声明参数的场景：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(T a)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无法写成</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(? extends Number a)</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>既要生产又要消费的场景：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;? <span class="built_in">super</span> T&gt;&gt; <span class="keyword">void</span> <span class="title function_">max</span><span class="params">(List&lt;T&gt; list)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (list == <span class="literal">null</span> || list.size() == <span class="number">0</span>) <span class="keyword">return</span>; </span><br><span class="line">    <span class="comment">// 生产 </span></span><br><span class="line">    <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> list.get(<span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; list.size(); i++) &#123;  </span><br><span class="line">        <span class="comment">// 消费</span></span><br><span class="line">        <span class="keyword">if</span> (list.get(i).compareTo(result) &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">            result = list.get(i);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************下面是相同功能方法的不同定义方式***************/</span></span><br><span class="line"><span class="comment">// 泛型方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">(List&lt;? extends T&gt; list)</span> &#123; </span><br><span class="line">    <span class="keyword">for</span> (T t : list) &#123;  </span><br><span class="line">        t.intValue();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">(List&lt;? extends Number&gt; list)</span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> (Number t : list) &#123;  </span><br><span class="line">        t.intValue();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************下面是相同功能方法的不同定义方式***************/</span></span><br><span class="line"><span class="comment">// 泛型方法带通配符，高司令说的这种定义方式要好一些，这种从语义上要好理解一些</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*The general rule is to use wildcards when you can because code with *wildcards is generally more readable than code with multiple type *parameters. When deciding if you need a type variable, ask yourself *if that type variable is used to relate two or more parameters, or *to relate a parameter type with the return type. If the answer is *no, then a wildcard should suffice</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">copy1</span><span class="params">(List&lt;? <span class="built_in">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; src.size(); i++) &#123;  </span><br><span class="line">        dest.set(i, src.get(i));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型方法带上界</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, S <span class="keyword">extends</span> <span class="title class_">T</span>&gt; <span class="keyword">void</span> <span class="title function_">copy1</span><span class="params">(List&lt;T&gt; dest, List&lt;S&gt; src)</span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; src.size(); i++) &#123;  </span><br><span class="line">        dest.set(i, src.get(i));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.oracle.com/javase/tutorial/java/generics/index.html">Java Generic Tutorial</a><br><a href="https://book.douban.com/subject/26880667/">Java核心技术·卷 I（原书第10版）</a><br><a href="https://book.douban.com/subject/34907497/">深入理解Java虚拟机（第3版）</a><br><a href="https://stackoverflow.com/questions/18176594/when-to-use-generic-methods-and-when-to-use-wild-card">When to use generic methods and when to use wild-card?</a><br><a href="https://stackoverflow.com/questions/30763895/why-use-a-wild-card-capture-helper-method">Why use a wild card capture helper method?</a><br><a href="https://forums.oracle.com/ords/apexds/post/capture-conv-rev-reverse-what-s-the-point-8796">Capture Conv: rev&#x2F;reverse - what’s the point?</a><br><a href="https://stackoverflow.com/questions/4343202/difference-between-super-t-and-extends-t-in-java">Difference between &lt;? super T&gt; and &lt;? extends T&gt; in Java</a><br><a href="https://stackoverflow.com/questions/2723397/what-is-pecs-producer-extends-consumer-super">What is PECS (Producer Extends Consumer Super)?</a><br><a href="https://stackoverflow.com/questions/34985220/differences-between-copylist-super-t-dest-list-extends-t-src-and-co">Differences between copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src)  and copy(List&lt;T&gt; dest, List&lt;? extends T&gt; src)</a>  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;泛型的定义&quot;&gt;&lt;a href=&quot;#泛型的定义&quot; class=&quot;headerlink&quot; title=&quot;泛型的定义&quot;&gt;&lt;/a&gt;泛型的定义&lt;/h2&gt;&lt;h3 id=&quot;泛型类的定义&quot;&gt;&lt;a href=&quot;#泛型类的定义&quot; class=&quot;headerlink&quot; title=&quot;泛</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>谁让你创建两个对象的？</title>
    <link href="http://example.com/2024/08/28/shui-rang-ni-chuang-jian-liang-ge-dui-xiang-de/"/>
    <id>http://example.com/2024/08/28/shui-rang-ni-chuang-jian-liang-ge-dui-xiang-de/</id>
    <published>2024-08-28T13:15:04.000Z</published>
    <updated>2024-12-27T01:25:38.427Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h2><p>之前遇到过一个问题，在一个微服务的目录下有相同功能 jar 包的两个不同的版本，其中一个版本里面的类有 @Component 注解，另外一个版本的类里面没有 @Component 注解，且按照加载的顺序，没有 @Component 注解的 jar 包顺序还在前面，如下图所示：<br><img src="https://raw.githubusercontent.com/sparkchans/pictures/main/20240928161901.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/sparkchans/pictures/main/20240928154946.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/sparkchans/pictures/main/20240928154906.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/sparkchans/pictures/main/20240928155130.png" alt="image.png"></p><p>按照类加载的顺序来说，只会加载没有 @Component 注解的类，如下图所示：<br><img src="https://raw.githubusercontent.com/sparkchans/pictures/main/20240928155420.png" alt="image.png"></p><p>但是实际上发现 Spring 还是基于这个类创建了 Bean如下图所示：<br><img src="https://raw.githubusercontent.com/sparkchans/pictures/main/20240928155532.png" alt="image.png"></p><p>为啥加载的类明明没有注解，但是 Spring 为什么还是创建了这个类的 Bean？初步猜测 <strong>Spring 不是通过读取已加载的类是否有 @Component 注解</strong>来判断是否要创建 Bean的。</p><h2 id="源码剖析"><a href="#源码剖析" class="headerlink" title="源码剖析"></a>源码剖析</h2><p>Spring 中扫描注解修饰的 Bean 是在 ClassPathBeanDefinitionScanner#scanCandidateComponents() 方法里面实现的，这个方法里面会根据配置的 scanBasePackages 从 CLASSPATH 下所有的 jar 包里面去找符合这个包路径的类，如下图所示：<br><img src="https://raw.githubusercontent.com/sparkchans/pictures/main/20240928160742.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/sparkchans/pictures/main/20240928160907.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/sparkchans/pictures/main/20240928161017.png" alt="image.png"><br>然后读取这些 Class 文件的内容，判断它们是否有 @Component 注解，如果有后续就会创建一个对应的 Bean。<br><img src="https://raw.githubusercontent.com/sparkchans/pictures/main/20240928161227.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/sparkchans/pictures/main/20240928162530.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题现象&quot;&gt;&lt;a href=&quot;#问题现象&quot; class=&quot;headerlink&quot; title=&quot;问题现象&quot;&gt;&lt;/a&gt;问题现象&lt;/h2&gt;&lt;p&gt;之前遇到过一个问题，在一个微服务的目录下有相同功能 jar 包的两个不同的版本，其中一个版本里面的类有 @Component</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>灵活的 SPI！</title>
    <link href="http://example.com/2024/07/21/ling-huo-de-spi/"/>
    <id>http://example.com/2024/07/21/ling-huo-de-spi/</id>
    <published>2024-07-21T13:15:04.000Z</published>
    <updated>2024-12-27T01:22:54.964Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用SPI机制前后的代码变化"><a href="#使用SPI机制前后的代码变化" class="headerlink" title="使用SPI机制前后的代码变化"></a>使用SPI机制前后的代码变化</h2><ul><li>加载MySQL对JDBC的Driver接口实现<br>在未使用SPI机制之前，使用JDBC操作数据库的时候，一般会写如下的代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过这行代码手动加载MySql对Driver接口的实现类</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>)</span><br><span class="line">DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/study&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br></pre></td></tr></table></figure>在使用了SPI机制之后，就直接可以调用<code>DriverManager.getConnection()</code>方法获取连接了。</li><li>SLF4J查找日志门面实现<br>在未使用SPI机制之前，SLF4J日志门面在查找具体的日志实现时，需要每个实现提供一个叫<code>org.slf4j.com.impl.StaticLoggerBinder.class</code>类，这里其实就跟SPI机制有点类似了，这个类实现了和SPI机制中的配置文件的功能，通过这个类来实现和具体实现的绑定关系。<br><img src="https://raw.githubusercontent.com/sparkchans/pictures/main/20240721170318.png" alt="20240721170318"><br>使用了SPI机制之后则是通过<code>SLF4JServiceProvider</code>类来实现和具体实现的绑定关系。<br><img src="https://raw.githubusercontent.com/sparkchans/pictures/main/20240721171037.png" alt="20240721171037"><br><img src="https://raw.githubusercontent.com/sparkchans/pictures/main/20240721174312.png" alt="20240721174312"></li></ul><h2 id="SPI代码实现案例"><a href="#SPI代码实现案例" class="headerlink" title="SPI代码实现案例"></a>SPI代码实现案例</h2><p>假设现在有一个Plugin的接口，调用方通过<code>PluginFactory</code>中的<code>installPlugins</code>方法来加载实现实现类，并进行调用，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Plugin接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Plugin</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">install</span><span class="params">(Map&lt;Object, Object&gt; context)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PluginFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">installPlugins</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;Object, Object&gt; context = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        context.put(<span class="string">&quot;_beans&quot;</span>, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        context.put(<span class="string">&quot;_version&quot;</span>, <span class="string">&quot;1.0.0&quot;</span>);</span><br><span class="line">        context.put(<span class="string">&quot;_aspects&quot;</span>, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里通过ServiceLoader加载Plugin的实现类</span></span><br><span class="line">        ServiceLoader&lt;Plugin&gt; loader = ServiceLoader.load(Plugin.class);</span><br><span class="line">        <span class="keyword">for</span> (Plugin plugin : loader) &#123;</span><br><span class="line">            plugin.install(context);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">PluginFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PluginFactory</span>();</span><br><span class="line">        factory.installPlugins();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Plugin接口实现者的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogPlugin</span> <span class="keyword">implements</span> <span class="title class_">Plugin</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LogManager.getLogger();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">install</span><span class="params">(Map&lt;Object, Object&gt; context)</span> &#123;</span><br><span class="line">        LOGGER.info(<span class="string">&quot;Login plugin is initiating...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/sparkchans/pictures/main/20240721214035.png" alt="20240721214035"><br><img src="https://raw.githubusercontent.com/sparkchans/pictures/main/20240721214130.png" alt="20240721214130"></p><p>使用SPI机制有个好处就是：当需要切换不同的实现类时，无需对业务代码进行适配修改，直接将Maven配置里面的实现依赖切换即可，对于实际的环境可能就是直接将对应的jar包替换到对应的lib目录下，然后重启服务即可。</p><h2 id="SPI代码实现原理"><a href="#SPI代码实现原理" class="headerlink" title="SPI代码实现原理"></a>SPI代码实现原理</h2><p>ServiceLoader的load方法实现原理是通过接口的全限定名称去读取<code>META-INF/services</code>路径下的文件，获取文件里面实现类的全限定名，然后加载该类，并通过反射的方式调用构造器获取实现类的实例，然后返回，如下图所示：<br><img src="https://raw.githubusercontent.com/sparkchans/pictures/main/20240721215047.png" alt="20240721215047"></p><p><img src="https://raw.githubusercontent.com/sparkchans/pictures/main/20240721214737.png" alt="20240721214737"></p><p><img src="https://raw.githubusercontent.com/sparkchans/pictures/main/20240721215650.png" alt="20240721215650"></p><p><img src="https://raw.githubusercontent.com/sparkchans/pictures/main/20240721214937.png" alt="20240721214937"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;使用SPI机制前后的代码变化&quot;&gt;&lt;a href=&quot;#使用SPI机制前后的代码变化&quot; class=&quot;headerlink&quot; title=&quot;使用SPI机制前后的代码变化&quot;&gt;&lt;/a&gt;使用SPI机制前后的代码变化&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;加载MySQL对JDBC的Dri</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>你知道 JVM 怎么优化反射的么？</title>
    <link href="http://example.com/2024/07/14/ni-zhi-dao-jvm-zen-me-you-hua-fan-she-de-me/"/>
    <id>http://example.com/2024/07/14/ni-zhi-dao-jvm-zen-me-you-hua-fan-she-de-me/</id>
    <published>2024-07-14T13:15:04.000Z</published>
    <updated>2024-12-27T01:23:28.383Z</updated>
    
    <content type="html"><![CDATA[<h2 id="优化原理"><a href="#优化原理" class="headerlink" title="优化原理"></a>优化原理</h2><p>Java中如果对一个方法采用反射的方式进行调用，一旦这个方法调用的次数达到阈值，这个时候JVM会自动对该调用进行优化，内部会自动转换为对某个类或者实例方法的调用来提高效率。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">Method.invoke --&gt; </span><br><span class="line">DelegatingMethodAccessorImpl.invoke --&gt;</span><br><span class="line">NativeMethodAccessorImpl.invoke</span><br></pre></td></tr></table></figure><h2 id="代码调用链"><a href="#代码调用链" class="headerlink" title="代码调用链"></a>代码调用链</h2><p>通过<code>Method</code>对象调用<code>invoke</code>方法：<br><img src="https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/506f2ea0feb34db8b794f29f53db118a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgamF2YWRheWRheXVw:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMjQzNjE3MzQ5NzYzNTcwMyJ9&rk3s=f64ab15b&x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018&x-orig-expires=1735790438&x-orig-sign=LAyUGdddp58Iw3R7MldWMrkHerE=" alt="image.png"><br>然后调用到<code>DelegatingMethodAccessorImpl</code>的<code>invoke</code>方法，该类是一个代理模式，实际上会调用到<code>NativeMethodAccessorImpl</code>的<code>invoke</code>方法：<br><img src="https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/bc9f365a4f314aeaa35b70965b682e43~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgamF2YWRheWRheXVw:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMjQzNjE3MzQ5NzYzNTcwMyJ9&rk3s=f64ab15b&x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018&x-orig-expires=1735790438&x-orig-sign=CdbR13V3q4Wi+s3qL7OA8ZjvNfA=" alt="image.png"></p><p><img src="https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/e6f3df3555fd4e90a61519459d4a9c1f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgamF2YWRheWRheXVw:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMjQzNjE3MzQ5NzYzNTcwMyJ9&rk3s=f64ab15b&x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018&x-orig-expires=1735790438&x-orig-sign=rxS04xido8HDcvvKdRkX1TTpBdQ=" alt="image.png"></p><p><img src="https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/64191af0a617482894f3af2646b49bb7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgamF2YWRheWRheXVw:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMjQzNjE3MzQ5NzYzNTcwMyJ9&rk3s=f64ab15b&x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018&x-orig-expires=1735790438&x-orig-sign=NVOMgsSBXn1qc+MHd+8VWohKOyA=" alt="image.png"><br><code>NativeMethodAccessorImpl</code>的<code>invoke</code>方法中会对当前调用方法的次数进行判断，如果达到了阈值（默认是15）时，就会动态生成一个类，并将设置为<code>DelegatingMethodAccessorImpl</code>类的代理对象，从而方法的实际调用就会变为调用这个动态类的<code>invoke</code>方法：<br><img src="https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/850e898ebade4c479f22a7e036efe003~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgamF2YWRheWRheXVw:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMjQzNjE3MzQ5NzYzNTcwMyJ9&rk3s=f64ab15b&x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018&x-orig-expires=1735790438&x-orig-sign=eMagBW9JOrdcrNtD3Y2+iYJNceQ=" alt="image.png"></p><p><img src="https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/cb21d25fb5794d1382c0e5d6c8d9bc6d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgamF2YWRheWRheXVw:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMjQzNjE3MzQ5NzYzNTcwMyJ9&rk3s=f64ab15b&x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018&x-orig-expires=1735790438&x-orig-sign=3Gbwi1x5n7yjehngLuxAej+QbmM=" alt="image.png"></p><p><img src="https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/54aa33e0446645e3bb961da2c8a8d702~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgamF2YWRheWRheXVw:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMjQzNjE3MzQ5NzYzNTcwMyJ9&rk3s=f64ab15b&x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018&x-orig-expires=1735790438&x-orig-sign=DmTTTsG+EUq40rC0d0EtyaGbd/k=" alt="image.png"></p><p><img src="https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/f3811d85b53841659ca9bf67e258ecad~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgamF2YWRheWRheXVw:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMjQzNjE3MzQ5NzYzNTcwMyJ9&rk3s=f64ab15b&x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018&x-orig-expires=1735790438&x-orig-sign=LyV7AofXXZ8TUpDDqmFe11GQGkc=" alt="image.png"><br>通过<code>Arthas</code>的<code>jad</code>命令反编译类可以看到这个动态生成的类的<code>invoke</code>方法的实现，可以看到<code>invoke</code>的方法里面没有再去调用本地方法了，而是相当于直接调用类的静态方法：<br><img src="https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/dfe8997aa2f3423db4827865fe93edbf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgamF2YWRheWRheXVw:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMjQzNjE3MzQ5NzYzNTcwMyJ9&rk3s=f64ab15b&x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018&x-orig-expires=1735790438&x-orig-sign=Oh+tQsgPt/7LUSboUkR0rIZK+Hs=" alt="image.png"></p><h2 id="控制参数"><a href="#控制参数" class="headerlink" title="控制参数"></a>控制参数</h2><p>Java中如果调用反射方法的次数过多，Java中会自动把反射方法的调用优化为自动调用生成的动态类。Java中通过几个JVM属性来控制。 <code>sun.reflect.noInflation</code> 用来控制是否直接生成动态类；</p><p><img src="https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/8663fadb3b654d9a9a8ee7a85c9598e5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgamF2YWRheWRheXVw:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMjQzNjE3MzQ5NzYzNTcwMyJ9&rk3s=f64ab15b&x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018&x-orig-expires=1735790438&x-orig-sign=XPZeugslAUPiE+vlBySoS3VM05c=" alt="image.png"><br><code>sun.reflect.inflationThreshold</code> 用来控制生成动态类的阈值，默认值为15；</p><p><img src="https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/0b2b6d9470d140a2a421b746eb32ecc9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgamF2YWRheWRheXVw:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMjQzNjE3MzQ5NzYzNTcwMyJ9&rk3s=f64ab15b&x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018&x-orig-expires=1735790438&x-orig-sign=gKQIEZeQMCJpNzf7MY5XZXrzRfQ=" alt="image.png"></p><p>在Idea中可以通过以下方式设置JVM属性：</p><p><img src="https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/5915c9cf39854acebd92e34849d7dc63~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgamF2YWRheWRheXVw:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMjQzNjE3MzQ5NzYzNTcwMyJ9&rk3s=f64ab15b&x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018&x-orig-expires=1735790438&x-orig-sign=g3gzWcaNq/0TaYqQsw7vU1KUuSE=" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;优化原理&quot;&gt;&lt;a href=&quot;#优化原理&quot; class=&quot;headerlink&quot; title=&quot;优化原理&quot;&gt;&lt;/a&gt;优化原理&lt;/h2&gt;&lt;p&gt;Java中如果对一个方法采用反射的方式进行调用，一旦这个方法调用的次数达到阈值，这个时候JVM会自动对该调用进行优化，内部会</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>是谁造成了 NoClassDefFoundError？</title>
    <link href="http://example.com/2023/11/06/shi-shui-zao-cheng-liao-noclassdeffounderror/"/>
    <id>http://example.com/2023/11/06/shi-shui-zao-cheng-liao-noclassdeffounderror/</id>
    <published>2023-11-06T13:15:04.000Z</published>
    <updated>2024-12-26T14:14:13.378Z</updated>
    
    <content type="html"><![CDATA[<p>半夜睡得正香的时候，突然接到警告电话，于是翻起身就打卡电脑连上环境查看是什么情况？登录上之后发现有个微服务占用的句柄数量一直在持续上涨，最终导致了微服务内存溢出挂掉了。这个微服务在运行的过程中会建立<code>SSH</code>连接，且之前这个微服务已经遇到过很多次类似的情况了，因此第一反应是哪里建立的连接又没有关闭。</p><p>猜肯定是猜不出来的，所以第一步肯定先看下日志里面哪里在报错，然后才好对症下药。打开日志之后，经过一番排查，发现日志里面有个很奇怪的报错，日志里面有打印<code>NoClassDefFoundError</code>。最开始的我对这个错误的理解是不够深刻的，我的第一反应是<code>Class</code>文件找不到了。于是我切换到微服务的路径下，去找这个<code>Class</code>文件，发现文件是存在的。于是我又想，难道是文件的权限不对？我又用了<code>ll</code>命令看了一下文件的权限，发现文件的权限也是对的。这个时候我有点懵了，心想完了，这道题不会呀，老师没教过呀！</p><p>没办法，为了保住工作，硬着头皮还是得上。俗话说，源码之下无秘密，只有根据堆栈找到对应的源代码进行分析，看看有什么怀疑点，然后又从网上搜索了一下<code>NoClassDefFoundError</code>报错的含义。经过我的深思熟虑终于发现了问题的所在。</p><p>首先需要了解一下<code>NoClassDefFoundError</code>的报错含义，参考<a href="https://stackoverflow.com/questions/34413/why-am-i-getting-a-noclassdeffounderror-in-java">why-am-i-getting-a-noclassdeffounderror-in-java</a>这个帖子：</p><p><img src="https://raw.githubusercontent.com/sparkchans/pictures/main/image-20231106165735010.png" alt="image-20231106165735010"></p><blockquote><p>这段话说：NoClassDefFoundError这个报错说明之前JVM尝试过去加载这个类，但是因为某些原因失败了。现在又要使用到这个类，所以又会触发这个类的加载，但是因为之前加载这个类失败了，所以这次就不会去加载这个类了，而是直接抛出NoClassDefFoundError这个报错。</p></blockquote><p>如果上面这段话不好理解，可以看下面这个例子，这个例子也是来自于上面那个帖子中的回答：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NoClassDefFoundError</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 这里尝试new一个对象，会触发SimpleCalculator的第一次加载</span></span><br><span class="line">            <span class="type">SimpleCalculator</span> <span class="variable">calculator1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleCalculator</span>();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            System.out.println(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里又尝试new一个对象，会触发SimpleCalculator的第二次加载</span></span><br><span class="line">        <span class="type">SimpleCalculator</span> <span class="variable">calculator2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleCalculator</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleCalculator</span> &#123;</span><br><span class="line">    <span class="comment">// 类加载的时候会初始化这个类变量，这里会抛出一个运行时异常</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">undefined</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/sparkchans/pictures/main/image-20231106170419903.png" alt="image-20231106170419903"></p><p>从上面的运行结果可以看到，在代码的第12行抛出了<code>NoClassDefFoundError</code>的报错，这里也是<strong>第二次</strong>尝试加载这个类的地方。第一次尝试初始化<code>SimpleCalculator</code> 这个类时，因为初始化会初始化 <code>undefined</code> 这个变量，而这个变量在初始化过程中会抛出一个异常，满足了第一次报错的条件，然后第12行尝试第二次初始化这个类，因为第一次已经初始化失败了，这个时候 JVM 就直接抛出<code>NoClassDefFoundError</code> 这个报错，而不是尝试再次去加载这个类。</p><p>当然实际的代码不可能会写出这么明显的Bug，我出问题的代码大概是长如下这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XXXUtils</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">XXXBean</span> <span class="variable">bean</span> <span class="operator">=</span> SpringContextUtils.getBean(XXXBean.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringContextUtils</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">getBean</span><span class="params">(Class&lt;T&gt; clazz)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> context.getBean(clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XXXClazz</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">xxxMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        XXXUtils.xxxMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Session</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">XXX</span> <span class="variable">conn</span> <span class="operator">=</span> xxx;</span><br><span class="line">    &#125; finnaly &#123;</span><br><span class="line">        XXXUtils.closeConn(conn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的工具类 <code>XXXUtils</code> 实际依赖了 <code>SpringContexUtils</code> 来获取 <code>Bean</code>，也就是依赖 <code>Spring</code> 上下文初始化好。但是实际在服务启动的过程中又触发了 <code>XXXClass</code>  的 <code>xxxMethod</code> 调用了 <code>XXXUtils</code> 的方法，这个时候就会触发 <code>XXXUtils</code> 的类加载，也就会触发它的 <code>bean</code> 变量的初始化，但是由于这个时候 <code>Spring </code> 上下文还没有初始化好，因此调用 <code>SpringContextUtils.getBean()</code> 方法就会抛出异常。在第一次初始化 <code>XXXUtils</code> 失败之后，等到服务正常启动，其它地方再调用 <code>XXXUtils</code>的方法时，就会抛出 <code>NoClassDefFoundError</code> 错误，导致了 <code>XXXUtils</code> 的所有方法都不可用，而正常的SSH连接结束之后，会调用 <code>XXXUtils.closeConn()</code> 方法关闭连接，当然，因为这个时候方法不可用，所以连接也关不掉，最终导致了的句柄数量不断上涨，服务也挂掉了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;半夜睡得正香的时候，突然接到警告电话，于是翻起身就打卡电脑连上环境查看是什么情况？登录上之后发现有个微服务占用的句柄数量一直在持续上涨，最终导致了微服务内存溢出挂掉了。这个微服务在运行的过程中会建立&lt;code&gt;SSH&lt;/code&gt;连接，且之前这个微服务已经遇到过很多次类似的</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>一个由硬链接引发的问题</title>
    <link href="http://example.com/2022/06/26/yi-ge-you-ying-lian-jie-yin-fa-de-wen-ti/"/>
    <id>http://example.com/2022/06/26/yi-ge-you-ying-lian-jie-yin-fa-de-wen-ti/</id>
    <published>2022-06-25T16:00:00.000Z</published>
    <updated>2024-12-27T01:28:34.043Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>最近关于 Fastjson 的漏洞又被爆出来了，作为修理工（哦不，专业的软件工程师），又到了我们表演的时候了。</p><p><img src="https://raw.githubusercontent.com/sparkchans/pictures/master/%E8%AF%B7%E5%BC%80%E5%A7%8B%E4%BD%A0%E7%9A%84%E8%A1%A8%E6%BC%94.jpg"></p><p>我们有很多服务是用的老版本的有漏洞的jar包，为了解决这个漏洞问题，我们决定来个偷梁换柱，使用新版本的jar包直接把老版本的有漏洞的jar版本直接覆盖掉。哎哎哎，要想程序搞得好，三十六计不可少。</p><p><img src="https://raw.githubusercontent.com/sparkchans/pictures/master/%E5%81%B7%E6%A2%81%E6%8D%A2%E6%9F%B1.png"></p><h2 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h2><p>既然方案确定了，那就开始干，具体思路如下：</p><ul><li>从环境上找出老版本的jar包，然后备份到一个备份路径下，这里备份是为了<strong>支持回退</strong>的功能。</li><li>然后把新版本的jar包拷贝到老版本jar包的路径下。</li><li>重启所有的微服务是jar包生效。</li></ul><p>代码的逻辑如下图所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for 老版本的jar包 in 所有老版本的jar包; do</span><br><span class="line">     备份老版本的jar包</span><br><span class="line">     将新版本的jar包拷贝覆盖老版本的jar包</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>整体思路很简单，但是问题就出在这个备份上面。在实际的测试过程中，发现备份的目录下，jar包的版本大多数都变成新版本的jar包了，而不是老版本的jar包，如下图所示，在 <code>/tmp/home/testuser </code> 下的 <code>fastjson-1.2.70.jar</code> 这个包的 Hash 值实际上和 <code>fastjson-1.2.83.jar</code> 这个包的 Hash 值一样。</p><p><img src="https://raw.githubusercontent.com/sparkchans/pictures/master/%E6%88%AA%E5%9B%BE%E4%B8%80.png"></p><p><img src="https://raw.githubusercontent.com/sparkchans/pictures/master/image-20220626193219265.png"></p><p>最开始一直以为是自己代码逻辑写的有问题，于是一遍一遍的检查。我先把新版本的jar包覆盖老版本的 jar 包这个逻辑去掉，然后计算备份路径下所有的 Hash 值，发现都是老版本的 jar 包，是没有问题的。</p><p>但是一旦我把覆盖老版本的 jar 包逻辑加上去，这个备份的 jar 包版本就变了，我反反复复搞了好几次结果都是一样的，真是让我百思不得其解。困扰程序员的两大难题之一在我脑海中产生了，它为啥就跑不起来呢？</p><p><img src="https://fastly.jsdelivr.net/gh/filess/img0@main/2022/06/26/1656243666307-ba33ce58-83db-446c-86b8-468cfa041b10.jpg"></p><p>既然看不出来，那就只能使用程序员的必杀器了，Debug 一把。我把每次循环执行覆盖操作后，备份目录的下的 jar 的 Hash 值都算了一下，结果发现在执行第二次循环的时候，备份目录的下的 jar 文件就已经变成了新版本的jar包文件了。</p><p>观察到这个现象之后，我就开始思考为啥会出现这种情况呢？第二个循环的逻辑明明和第一次的逻辑是一样的，为啥结果就变了呢？</p><p><img src="https://raw.githubusercontent.com/sparkchans/pictures/master/%E6%8C%A0%E5%A4%B4.jpg"></p><p>当天搞了很久也没有找到原因是啥，脑壳都给我搞昏了。没办法，明天接着搞。第二天早上来，由于经过了一晚上的回血，思路又清晰起来了，觉得自己又行了。</p><p><img src="https://raw.githubusercontent.com/sparkchans/pictures/master/%E5%8F%88%E8%A1%8C%E4%BA%861.jpg"></p><p>这个时候我想起来，之前有人好像给我说过，我们的jar包是做的硬链接的。这个让我想到了一个经典的面试题：Linux 的软链接和硬链接的区别是啥？区别是啥来着？嗯嗯……，想不起来了，书到用时方恨少啊，默默的流下了没有知识的泪水。</p><p>网上找了一些文章来看，又从电脑屏幕下把压着的《鸟哥的 Linux 私房菜》取出来复习一下。</p><p>然后登录到环境上，看了一下环境上老版本的 jar 包，发现确实是做的硬链接。为了演示这个情况，我在我自己的环境上复现了一下这种情况，如下图所示：</p><p><img src="https://raw.githubusercontent.com/sparkchans/pictures/master/%E6%88%AA%E5%9B%BE%E4%BA%8C.png"></p><p>软链接和硬链接的区别可以参考网上的资料和书籍，我在这里就不细讲了。针对我当前遇到的这个问题，可以打个不恰当的比喻：硬链接就好像你照镜子一样，你做了什么样的改变，镜子里面的你也会做同样的改变。如上图所示，当我们改变 <code>/home/testuser</code> 目录下的 <code>fastjson-1.2.70.jar</code> 这个文件的内容时，<code>/home/admin</code> 目录下的 <code>fastjson-1.2.70.jar</code> 文件的内容会变得和它一样。</p><p>知道了这个特性，我们再结合代码来分析一下：</p><ul><li><p>已知条件：环境上有两个jar包文件: <code>/home/testuser/fastjson-1.2.70.jar</code> 和 <code>/home/admin/fastjson-1.2.70.jar</code>  这两个jar包是硬链接关系</p></li><li><p>推导：当我们执行第一次for循环到<strong>将新版本的jar包拷贝覆盖老版本的jar包</strong>这个步骤时，会把其中一个路径下的jar包版本替换成新版本的jar包了，这个时候相当于<code>/home/testuser/fastjson-1.2.70.jar</code> 和 <code>/home/admin/fastjson-1.2.70.jar</code>  这两个jar包都已经变成新版本的jar包了；当第二次for循环到<strong>备份老版本的jar包</strong>时，这个时候备份的是实际上已经是新版本的jar包了。这个就是为啥第二次以后备份的jar包版本都是新版本的原因了。</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for 老版本的jar包 in 所有老版本的jar包; do</span><br><span class="line">     备份老版本的jar包</span><br><span class="line">     将新版本的jar包拷贝覆盖老版本的jar包</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>知道原因了，我们就思考上面的代码应该怎么改？很显然，备份和拷贝覆盖老版本的jar包这两个动作应该拆分到两个for循环中去实现才行，这样的备份这个for循环里面就会备份的是所有老版本的jar包。如下面的代码所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for 老版本的jar包 in 所有老版本的jar包; do</span><br><span class="line">     备份老版本的jar包</span><br><span class="line">done</span><br><span class="line">for 老版本的jar包 in 所有老版本的jar包; do</span><br><span class="line">     将新版本的jar包拷贝覆盖老版本的jar包</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>这个问题的解决主要是要理解硬链接的原理。说实话这个知识之前也看过很多遍，每次看的时候都觉得自己懂了，但是真正遇到问题的时候，才发现自己根本就没有懂。</p><p><img src="https://raw.githubusercontent.com/sparkchans/pictures/master/%E4%BD%A0%E4%B8%8D%E6%87%82.png"></p><p>通过这次问题的解决，我想我应该是对硬链接有了一定的了解。其实在日常的工作中，很多的小问题背后其实都对应的一些知识点的，如果我们能够把这些小问题搞清楚，其实对我们<strong>真正</strong>理解和掌握这个知识是有很大帮助的。好了，今天就到这里了，朋友们，我们下期再见！</p><p><img src="https://raw.githubusercontent.com/sparkchans/pictures/master/%E5%86%8D%E8%A7%81.gif"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题背景&quot;&gt;&lt;a href=&quot;#问题背景&quot; class=&quot;headerlink&quot; title=&quot;问题背景&quot;&gt;&lt;/a&gt;问题背景&lt;/h2&gt;&lt;p&gt;最近关于 Fastjson 的漏洞又被爆出来了，作为修理工（哦不，专业的软件工程师），又到了我们表演的时候了。&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>我掉到 MessageFormat 的坑里面去了！</title>
    <link href="http://example.com/2022/06/19/wo-diao-dao-messageformat-de-keng-li-mian-qu-liao/"/>
    <id>http://example.com/2022/06/19/wo-diao-dao-messageformat-de-keng-li-mian-qu-liao/</id>
    <published>2022-06-19T13:15:04.000Z</published>
    <updated>2024-12-27T01:26:05.331Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h2><p>某个业务功能需要通过SSH协议执行命令查询一些数据，而某次查询居然没有得到任何结果，导致界面没有任何数据，但是手动执行这个命令又是能够查询到数据的。刨了半天日志也确实没有看到日志里面有什么异常的信息，百思不得其解数据究竟去哪里了？？？</p><p><img src="https://raw.githubusercontent.com/sparkchans/pictures/master/1.gif" alt="1"></p><h2 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h2><p>看了一段时间还是没有什么头绪，这个时候内心开始慌了。</p><p><img src="https://raw.githubusercontent.com/sparkchans/pictures/master/image-20220619144748654.png" alt="image-20220619144748654"></p><p>赶紧看了一下提交记录，确认了一下代码不是我写的，于是心里稍稍微淡定了一点，别人问起也好说不是我写的嘛！</p><p><img src="https://raw.githubusercontent.com/sparkchans/pictures/master/03.gif" alt="03"></p><p>虽然代码不是我写的，但是问题还是要继续看的。毕竟拿了钱，就要干活的嘛。</p><p><img src="https://raw.githubusercontent.com/sparkchans/pictures/master/04.gif" alt="04"></p><p>接下来就只能分析代码了。首先分析了一下最有可能出错的地方，就是解析命令查询的响应逻辑。把这个地方的代码和手动执行命令得到的结果放在一起分析，发现根据这个响应结果是能够正常的得到响应结果的。</p><p>看了一会儿也确实没有发现问题，又去看了一下命令拼接的代码，拼接的逻辑就一行，应该是不会出问题的。</p><p>没办法了，又去看了看日志，这个时候发现日志里面有打印发送执行的命令。定睛一看，我擦，咋多了个逗号呢？又揉了揉眼镜，确认自己没有看错误。</p><p><img src="https://raw.githubusercontent.com/sparkchans/pictures/master/6.gif" alt="6"></p><p>这个时候再回去看一下代码，怎么看这个 <code>MessageFormat</code> 都有点问题，但是一时又找不到啥证据。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Integer <span class="title function_">getMaxIndex</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 返回最大的索引值 1035</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">queyBySsh</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//  这里期望拼接的命令是 show index 1035，但是实际的命令却是 show index 1,035</span></span><br><span class="line">    <span class="comment">// 最终得到的命令多了个英文的逗号 </span></span><br><span class="line">    <span class="type">String</span> <span class="variable">command</span> <span class="operator">=</span> MessageFormat(<span class="string">&quot;show index &#123;0&#125;&quot;</span>, getMaxIndex());</span><br><span class="line">    <span class="comment">// 通过SSH执行这个命令查询</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/sparkchans/pictures/master/9.gif" alt="9"></p><p>后来突然想起来之前看到过的一个Wiki，好像有关于描述 <code>MessageFormat</code> 的注意事项。赶紧去找来看一下，果然里面有写到当 <code>MessageFormat</code> 的参数是数字类型时，当数字超过 3 位数字以上时，每隔 3 位会多增加一个因为的逗号。所以根据上面的代码逻辑得到的就是 <code>show index 1,035</code> 了，结果中多了个英文的逗号，而将这个拼接出来的命令手动执行是查不出来数据的。终于破案了，撒花，撒花，撒花！！！</p><h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><p>第一种方法是将数字转为字符串，然后再进行格式化，将上面的代码修改为如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">queyBySsh</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 这里拼接的时候先调用一下 String.valueOf() 方法</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">command</span> <span class="operator">=</span> MessageFormat(<span class="string">&quot;show index &#123;0&#125;&quot;</span>, String.valueOf(getMaxIndex()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种方法是增加 <code>MessageFormat</code> 的 <code>FormatStyle</code>，将上面的代码修改为如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">queyBySsh</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 这里的 # 就是定义的 FamatStyle</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">command</span> <span class="operator">=</span> MessageFormat(<span class="string">&quot;show index &#123;0, number, #&#125;&quot;</span>, getMaxIndex());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题现象&quot;&gt;&lt;a href=&quot;#问题现象&quot; class=&quot;headerlink&quot; title=&quot;问题现象&quot;&gt;&lt;/a&gt;问题现象&lt;/h2&gt;&lt;p&gt;某个业务功能需要通过SSH协议执行命令查询一些数据，而某次查询居然没有得到任何结果，导致界面没有任何数据，但是手动执行这个命</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
  </entry>
  
</feed>
